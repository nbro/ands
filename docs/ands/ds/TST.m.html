<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ands.ds.TST API documentation</title>
    <meta name="description" content="# Meta info

Author: Nelson Brochado

Created: 05/09/2015

Updated: 03/02/2017

# Description

Terna..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ands.ds.TST.TST">TST</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ands.ds.TST.TST.__init__">__init__</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.all_pairs">all_pairs</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.contains">contains</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.count">count</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.delete">delete</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.insert">insert</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.is_empty">is_empty</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.keys_that_match">keys_that_match</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.keys_with_prefix">keys_with_prefix</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.longest_prefix_of">longest_prefix_of</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.search">search</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.search_iteratively">search_iteratively</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.size">size</a></li>
    <li class="mono"><a href="#ands.ds.TST.TST.traverse">traverse</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ands.ds.TST.TSTNode">TSTNode</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ands.ds.TST.TSTNode.__init__">__init__</a></li>
    <li class="mono"><a href="#ands.ds.TST.TSTNode.has_children">has_children</a></li>
    <li class="mono"><a href="#ands.ds.TST.TSTNode.is_left_child">is_left_child</a></li>
    <li class="mono"><a href="#ands.ds.TST.TSTNode.is_mid_child">is_mid_child</a></li>
    <li class="mono"><a href="#ands.ds.TST.TSTNode.is_right_child">is_right_child</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ands.ds.TST</span> module</h1>
  <h1>Meta info</h1>
<p>Author: Nelson Brochado</p>
<p>Created: 05/09/2015</p>
<p>Updated: 03/02/2017</p>
<h1>Description</h1>
<p>Ternary-search tries (or trees) combine the time efficiency of other tries
with the space efficiency of binary-search trees.</p>
<p>An advantage compared to hash maps is that ternary search tries support sorting,
but the <em>keys</em> of a ternary-search trie can only be <em>strings</em>,
whereas a hash map supports any kind of hashable keys.</p>
<h2>TSTs vs Hashing</h2>
<h3>Hashing</h3>
<ul>
<li>Need to examine entire key</li>
<li>Search miss and hits cost about the same</li>
<li>Performance relies on hash function</li>
<li>Does NOT support ordered symbol table operations</li>
</ul>
<h3>TSTs</h3>
<ul>
<li>Works only for strings (or digital keys)</li>
<li>Only examines just enough key characters</li>
<li>Search miss may involve only a few characters</li>
<li>Supports ordered symbol table operations:<ul>
<li>keys-that-match</li>
<li>keys-with-prefix</li>
<li>longest-prefix-of</li>
</ul>
</li>
</ul>
<h3>Bottom line</h3>
<p>TSTs are:</p>
<ul>
<li>faster than hashing (especially for search misses)</li>
<li>more flexible than red-black trees</li>
</ul>
<h1>References</h1>
<ul>
<li><a href="https://www.cs.upc.edu/~ps/downloads/tst/tst.html">Ternary Search Trees</a> by By Jon Bentley and Bob Sedgewick</li>
<li><a href="https://www.cs.princeton.edu/~rs/strings/">Fast Algorithms for Sorting and Searching Strings</a>, by Jon Bentley and Robert Sedgewick</li>
<li><a href="http://algs4.cs.princeton.edu/52trie/TST.java.html">TST.java</a>, Java implementation by Robert Sedgewick and Kevin Wayne</li>
<li><a href="https://www.youtube.com/watch?v=CIGyewO7868">Ternary Search Tries</a>, video lecture by Robert Sedgewick</li>
<li><a href="https://en.wikipedia.org/wiki/Ternary_search_tree">Ternary search tree</a> at Wikipedia</li>
<li><a href="http://stackoverflow.com/a/27178771/3924118">How to list in an alphabetical order the words of a ternary search tree?</a></li>
</ul>
<h1>Resources</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=xv4oRyqSKiw">Ternary search tree introduction</a>,
by <a href="https://www.udemy.com/user/holczerbalazs/">Balazs Holczer</a></li>
<li><a href="http://www.keithschwarz.com/interesting/code/?dir=ternary-search-tree">TernarySearchTree.hh</a>,
C++ implementation of a TST by Keith Schwarz, which provides a good analysis of the complexity of the operations of a TST.</li>
<li><a href="http://p2p.wrox.com/book-beginning-algorithms/60350-remove-method-ternary-search-tree.html">Remove method for Ternary Search Tree</a>,
at <a href="http://p2p.wrox.com/book-beginning-algorithms">http://p2p.wrox.com/book-beginning-algorithms</a></li>
<li><a href="http://www.javaworld.com/article/2075027/java-app-dev/plant-your-data-in-a-ternary-search-tree.html?page=1">Plant your data in a ternary search tree</a></li>
</ul>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST" class="source">
    <pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
# Meta info

Author: Nelson Brochado

Created: 05/09/2015

Updated: 03/02/2017

# Description

Ternary-search tries (or trees) combine the time efficiency of other tries
with the space efficiency of binary-search trees.

An advantage compared to hash maps is that ternary search tries support sorting,
but the _keys_ of a ternary-search trie can only be _strings_,
whereas a hash map supports any kind of hashable keys.

## TSTs vs Hashing

### Hashing

- Need to examine entire key
- Search miss and hits cost about the same
- Performance relies on hash function
- Does NOT support ordered symbol table operations

### TSTs

- Works only for strings (or digital keys)
- Only examines just enough key characters
- Search miss may involve only a few characters
- Supports ordered symbol table operations:
    - keys-that-match
    - keys-with-prefix
    - longest-prefix-of

### Bottom line

TSTs are:

- faster than hashing (especially for search misses)
- more flexible than red-black trees

# References

- [Ternary Search Trees](https://www.cs.upc.edu/~ps/downloads/tst/tst.html) by By Jon Bentley and Bob Sedgewick
- [Fast Algorithms for Sorting and Searching Strings](https://www.cs.princeton.edu/~rs/strings/), by Jon Bentley and Robert Sedgewick
- [TST.java](http://algs4.cs.princeton.edu/52trie/TST.java.html), Java implementation by Robert Sedgewick and Kevin Wayne
- [Ternary Search Tries](https://www.youtube.com/watch?v=CIGyewO7868), video lecture by Robert Sedgewick
- [Ternary search tree](https://en.wikipedia.org/wiki/Ternary_search_tree) at Wikipedia
- [How to list in an alphabetical order the words of a ternary search tree?](http://stackoverflow.com/a/27178771/3924118)

# Resources

- [Ternary search tree introduction](https://www.youtube.com/watch?v=xv4oRyqSKiw),
by [Balazs Holczer](https://www.udemy.com/user/holczerbalazs/)
- [TernarySearchTree.hh](http://www.keithschwarz.com/interesting/code/?dir=ternary-search-tree),
C++ implementation of a TST by Keith Schwarz, which provides a good analysis of the complexity of the operations of a TST.
- [Remove method for Ternary Search Tree](http://p2p.wrox.com/book-beginning-algorithms/60350-remove-method-ternary-search-tree.html),
at [http://p2p.wrox.com/book-beginning-algorithms](http://p2p.wrox.com/book-beginning-algorithms)
- [Plant your data in a ternary search tree](http://www.javaworld.com/article/2075027/java-app-dev/plant-your-data-in-a-ternary-search-tree.html?page=1)

"""


class TSTNode:
    """A TSTNode has 6 fields:

        - key, which is a character;
        - value, which is None if self is not a terminal node (of an inserted string in the TST);
        - parent, which is a pointer to a TSTNode representing the parent of self;
        - left, which is a pointer to a TSTNode whose key is smaller lexicographically than key;
        - right, which is similarly a pointer to a TSTNode whose key is greater lexicographically than key;
        - mid, which is a pointer to a TSTNode whose key is the following character of key in an inserted string."""

    def __init__(self, key, value=None, parent=None, left=None, mid=None, right=None):
        if not isinstance(key, str):
            raise TypeError("key must be an instance of str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        self.key = key
        self.value = value
        self.parent = parent
        self.left = left
        self.mid = mid
        self.right = right

    def is_left_child(self) -> bool:
        if not self.parent:
            raise AttributeError("self does not have a parent.")
        if self.parent.left:
            return self.parent.left == self
        else:
            return False

    def is_right_child(self) -> bool:
        if not self.parent:
            raise AttributeError("self does not have a parent.")
        if self.parent.right:
            return self.parent.right == self
        else:
            return False

    def is_mid_child(self) -> bool:
        if not self.parent:
            raise AttributeError("self does not have a parent.")
        if self.parent.mid:
            return self.parent.mid == self
        else:
            return False

    def has_children(self) -> bool:
        return self.left or self.right or self.mid

    def __str__(self):
        return "{0}: {1}".format(self.key, self.value)

    def __repr__(self):
        return self.__str__()


class TST:
    """Methods or fields that start with an underscore _ are considered private,
    so they should not be access and never modified from a client of this class.

    This TST does not allow (through public methods) empty strings to be inserted.

    In general the way the ternary search tree looks like
    depends highly on the order of insertion of the keys,
    that is, inserting the same keys but in different orders
    produces internally a different structure or shape of the TST."""

    def __init__(self):
        self._n = 0
        self._root = None

    def __invariants__(self) -> None:
        """These propositions should always be true at the BEGINNING
        and END of every PUBLIC method of this TST.

        Call this method if you want to ensure the invariants are holding."""
        assert self._n >= 0
        if self._n == 0:
            assert self._root is None
        elif self._n > 0:
            assert isinstance(self._root, TSTNode)
            assert self._root.parent is None

    def _is_root(self, u: TSTNode) -> bool:
        result = (self._root == u)
        if result:
            assert u.parent is None
        else:
            assert u.parent is not None
        return result

    def size(self) -> int:
        return self._n

    def count(self) -> int:
        """Counts the number of strings in self.

        This method recursively passes through all the nodes
        and counts the ones which have a non None value.

        You should clearly use size instead: 
        this method is here only for the fun of writing code!

        **Time complexity:** O(n), where n is the number of nodes in this TST."""
        c = self._count(self._root, 0)
        assert c == self.size()
        return c

    def _count(self, node: TSTNode, counter: int) -> int:
        """Helper method to `self.count`.

        **Time complexity:** O(m), where m is the number of nodes under `node`."""
        if node is None:  # base case
            return counter

        counter = self._count(node.left, counter)
        if node.value is not None:
            counter += 1

        counter = self._count(node.mid, counter)
        counter = self._count(node.right, counter)

        return counter

    def is_empty(self) -> bool:
        """**Time complexity:** O(1)."""
        return self._n == 0

    def insert(self, key: str, value: object) -> None:
        """Inserts the `key` into the symbol table and associates with it `value`,
        overwriting an eventual associated old value, if the `key` is already in self.

        If `key` is not an instance of `str`, `TypeError` is raised.
        If `key` is an empty string, `ValueError` is raised.
        If `value` is None, `ValueError` is raised.

        Nodes whose value is not None represent the last character of an inserted word.

        **Time complexity:** O(m + h), where m = length(key),
        which also represents how many times we follow the middle link,
        and h is the number of left and right turns.
        So a lower bound of the complexity would be &Omega(m);."""
        self.__invariants__()
        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")
        if value is None:
            raise ValueError("value cannot be None.")
        self._root = self._insert(self._root, key, value, 0)
        self.__invariants__()

    def _insert(self, node: TSTNode, key: str, value: object, index: int):
        """Inserts `key` with `value` into self starting from `node`."""
        if node is None:
            node = TSTNode(key[index])

        if key[index] < node.key:
            node.left = self._insert(node.left, key, value, index)
            node.left.parent = node
        elif key[index] > node.key:
            node.right = self._insert(node.right, key, value, index)
            node.right.parent = node
        else:  # key[index] == node.key
            if index < len(key) - 1:
                # If we're NOT at the end of the key, this is a match,
                # so we recursively call self._insert from index + 1,
                # and we move to the mid node (char) of node.
                # Note that the last index of the key is len(key) - 1.
                node.mid = self._insert(node.mid, key, value, index + 1)
                node.mid.parent = node
            else:
                if node.value is None:
                    self._n += 1
                node.value = value

        return node

    def search(self, key: str) -> object:
        """Returns the value associated with `key`, if `key` is in self, else None.

        If `key` is not an instance of `str`, `TypeError` is raised.
        If `key` is an empty string, `ValueError` is raised.

        The search in a TST works as follows.

        We start at the root and we compare its character with the first character of key.
            - If they are the same, we follow the middle link of the root node.
            - If the first character of key is smaller lexicographically
            than the key at the root, then we take the left link or pointer.
            We do this because we know that all strings that start with characters
            that are smaller lexicographically than key[0] are on its left subtree.
            - If the first character of key is greater lexicographically
            than the key at the root, we take similarly the right link or pointer.

        We keep applying this idea at every node.
        Moreover, WHEN THERE'S A MATCH, next time we compare the key
        of the next node with the next character of key.

        For example, if there's a match between the first node (the root) and key[0],
        we follow the middle link, and the next comparison is between
        the key of the specific next node and key[1], not key[0]!

        **Time complexity:** O(m + h).
        Check self.insert to see what m and h are."""
        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        node = self._search(self._root, key, 0)

        if node is not None:
            assert self.search_iteratively(key) == node.value
            return node.value
        else:
            assert self.search_iteratively(key) is None
            return None

    def _search(self, node: TSTNode, key: str, index: int) -> TSTNode:
        """Searches for the node containing the value associated with `key` starting from `node`.
        If returns None OR a node with value None if there's no such node."""
        if node is None:
            return None

        if key[index] < node.key:
            return self._search(node.left, key, index)
        elif key[index] > node.key:
            return self._search(node.right, key, index)
        elif index < len(key) - 1:  # This is a match, but we're not at the last character of key.
            return self._search(node.mid, key, index + 1)
        else:  # This is a match and we're at the last character of key.
            return node  # node could be None!!

    def search_iteratively(self, key: str) -> object:
        """Iterative alternative to self.search."""
        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        node = self._root

        if node is None:
            return None

        # Up to the penultimate index (i.e. len(key) - 1)
        # because if we reach the penultimate character and it's a match,
        # then we follow the mid node (i.e. we end up in what's possibly the last node).
        index = 0

        while index < len(key) - 1:
            while node and key[index] != node.key:
                if key[index] < node.key:
                    node = node.left
                else:
                    node = node.right

            if node is None:  # Unsuccessful search.
                return None
            else:
                # Arriving here only if exited from the while loop
                # because the condition key[i] != node.key was false,
                # that is key[index] == node.key, thus we follow the middle link.
                node = node.mid
                index += 1

        assert index == len(key) - 1

        # If node is not None, then we may still need to go left or right,
        # and we stop when either we find a node which has the same key as the last character of key,
        # or when `node` ends up being set to None, i.e. the key does not exist in this TST.
        while node and key[index] != node.key:
            if key[index] < node.key:
                node = node.left
            else:
                node = node.right

        if node is None:  # Unsuccessful search.
            return None
        else:  # We exit the previous while loop because key[index] == node.key.
            return node.value  # could also be None!!

    def contains(self, key: str) -> bool:
        """Returns True if `key` is in self, False otherwise.

        **Time complexity:** O(m + h).
        See the complexity analysis of self.insert for more info about m and h."""
        return self.search(key) is not None

    def delete(self, key: str) -> TSTNode:
        """Deletes and returns the value associated with `key` in this TST,
        if `key` is in this TST, otherwise it returns None.

        If `key` is not an instance of `str`, `TypeError` is raised.
        If `key` is an empty string, `ValueError` is raised.

        **Time complexity:** O(m + h + k).
        Check self.search to see what m and h are.
        k is the number of "no more necessary" cleaned up
        after deletion of the node associated with `key`.
        Unnecessary nodes are nodes with no children and value equal to None."""
        self.__invariants__()

        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        # Note: calling self._search, since self.search does not return a Node,
        # but the value associated with the key passed as parameter.
        node = self._search(self._root, key, 0)

        if node is not None and node.value is not None:
            # If node.value is None, it means
            result = node.value  # forgetting the string tracked by node.
            node.value = None
            self._n -= 1
            self._delete_fix(node)
        else:
            result = None

        self.__invariants__()
        return result

    def _delete_fix(self, u: TSTNode) -> None:
        """Does the clean up of this TST after deletion of node `u`."""
        assert u.value is None

        # While u has no children and his value is None,
        # forget about u and start from his parent.
        # So, this while loop terminates when either u is None,
        # u has at least one child, or u's value is not None.
        while u and not u.has_children() and u.value is None:
            if self._is_root(u):
                assert self._n == 0
                self._root = None
                break

            if u.is_left_child():
                u.parent.left = None
            elif u.is_right_child():
                u.parent.right = None
            else:
                u.parent.mid = None

            p = u.parent
            u.parent = None
            u = p

        if u.has_children() and u.value is None:
            assert self._count(u, 0) > 0

    def traverse(self) -> None:
        """Traverses all nodes in this TST and prints the key: value associations.

        **Time complexity:** O(n), where n is the number of nodes in self."""
        self._traverse(self._root, "")

    def _traverse(self, node: TSTNode, prefix: str) -> None:
        """Helper method to self.traverse.

        **Time complexity:** O(m), where m is the number of nodes under `node`."""
        if node is None:  # base case
            return

        self._traverse(node.left, prefix)
        if node.value is not None:
            print(prefix + node.key, ": ", node.value)

        self._traverse(node.mid, prefix + node.key)
        self._traverse(node.right, prefix)

    def keys_with_prefix(self, prefix: str) -> list:
        """Returns all keys in this TST that start with `prefix`.

        If `prefix` is not an instance of `str`, `TypeError` is raised.

        If `prefix` is an empty string, then all keys in this TST
        that start with an empty string, thus all keys are returned."""
        if not isinstance(prefix, str):
            raise TypeError("prefix must be an instance of str!")

        kwp = []

        if not prefix:
            self._keys_with_prefix(self._root, [], kwp)
        else:
            node = self._search(self._root, prefix, 0)

            if node is not None:
                if node.value is not None:
                    # A `key` equals to prefix was found in the TST with an associated value.
                    kwp.append(prefix)

                self._keys_with_prefix(node.mid, list(prefix), kwp)

        return kwp

    def _keys_with_prefix(self, node: TSTNode, prefix_list: list, kwp: list) -> None:
        """Returns all keys rooted at `node` given the prefix given as a list of characters `prefix_list`."""
        if node is None:
            return

        self._keys_with_prefix(node.left, prefix_list, kwp)

        if node.value is not None:
            kwp.append("".join(prefix_list + [node.key]))

        prefix_list.append(node.key)
        self._keys_with_prefix(node.mid, prefix_list, kwp)

        prefix_list.pop()
        self._keys_with_prefix(node.right, prefix_list, kwp)

    def all_pairs(self) -> dict:
        """Returns all pairs of key:value from this TST as a Python `dict`."""
        pairs = {}
        self._all_pairs(self._root, [], pairs)
        return pairs

    def _all_pairs(self, node: TSTNode, key_list: list, all_dict: list) -> None:
        if node is None:
            return

        self._all_pairs(node.left, key_list, all_dict)

        if node.value is not None:
            key = "".join(key_list + [node.key])
            assert key not in all_dict
            all_dict[key] = node.value

        key_list.append(node.key)
        self._all_pairs(node.mid, key_list, all_dict)

        key_list.pop()
        self._all_pairs(node.right, key_list, all_dict)

    def longest_prefix_of(self, query: str) -> str:
        """Returns the key in this TST which is the longest prefix of `query`,
        if such a key exists, else it returns None.

        If `query` is not a string `TypeError` is raised.
        If `query` is a string but empty, `ValueError` is raised.

        If this TST is empty, it returns an empty string."""
        if not isinstance(query, str):
            raise TypeError("query is not an instance of str!")
        if not query:
            raise ValueError("empty strings not allowed in this TST!")

        length = 0  # It keeps track of the length of the longest prefix of query.
        x = self._root
        i = 0

        while x is not None and i < len(query):
            c = query[i]

            if c < x.key:
                x = x.left
            elif c > x.key:
                x = x.right
            else:
                i += 1
                if x.value is not None:
                    length = i
                x = x.mid

        return query[:length]

    def keys_that_match(self, pattern: str) -> list:
        """Returns a list of keys of this TST that match `pattern`.

        A key `k` of length `m` matches `pattern` if:

        1. m = length(pattern), and
        2. Either k[i] == pattern[i] or k[i] == '.'.
            - Example: if `pattern == ".ood"`,
            then `k == "good"` would match, but not `k == "foodie"`.

        If `pattern` is not a `str`, `TypeError` is raised.
        If `pattern` is an empty string, `ValueError` is raised."""
        if not isinstance(pattern, str):
            raise TypeError("pattern is not an instance of str!")
        if not pattern:
            raise ValueError("pattern cannot be an empty string")

        keys = []
        self._keys_that_match(self._root, [], 0, pattern, keys)
        return keys

    def _keys_that_match(self, node: TSTNode, prefix_list: list, i: int, pattern: str, keys: list) -> None:
        """Stores in the list `keys` the of keys that match `pattern` starting from `node`."""
        if node is None:
            return

        c = pattern[i]

        if c == "." or c < node.key:
            self._keys_that_match(node.left, prefix_list, i, pattern, keys)

        if c == "." or c == node.key:

            if i == len(pattern) - 1 and node.value is not None:
                # If i is the last index and its value is not None
                keys.append("".join(prefix_list + [node.key]))

            if i < len(pattern) - 1:
                prefix_list.append(node.key)
                self._keys_that_match(node.mid, prefix_list, i + 1, pattern, keys)
                prefix_list.pop()

        if c == "." or c > node.key:
            self._keys_that_match(node.right, prefix_list, i, pattern, keys)
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ands.ds.TST.TST" class="name">class <span class="ident">TST</span></p>
      
  
    <div class="desc"><p>Methods or fields that start with an underscore _ are considered private,
so they should not be access and never modified from a client of this class.</p>
<p>This TST does not allow (through public methods) empty strings to be inserted.</p>
<p>In general the way the ternary search tree looks like
depends highly on the order of insertion of the keys,
that is, inserting the same keys but in different orders
produces internally a different structure or shape of the TST.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST" class="source">
    <pre><code>class TST:
    """Methods or fields that start with an underscore _ are considered private,
    so they should not be access and never modified from a client of this class.

    This TST does not allow (through public methods) empty strings to be inserted.

    In general the way the ternary search tree looks like
    depends highly on the order of insertion of the keys,
    that is, inserting the same keys but in different orders
    produces internally a different structure or shape of the TST."""

    def __init__(self):
        self._n = 0
        self._root = None

    def __invariants__(self) -> None:
        """These propositions should always be true at the BEGINNING
        and END of every PUBLIC method of this TST.

        Call this method if you want to ensure the invariants are holding."""
        assert self._n >= 0
        if self._n == 0:
            assert self._root is None
        elif self._n > 0:
            assert isinstance(self._root, TSTNode)
            assert self._root.parent is None

    def _is_root(self, u: TSTNode) -> bool:
        result = (self._root == u)
        if result:
            assert u.parent is None
        else:
            assert u.parent is not None
        return result

    def size(self) -> int:
        return self._n

    def count(self) -> int:
        """Counts the number of strings in self.

        This method recursively passes through all the nodes
        and counts the ones which have a non None value.

        You should clearly use size instead: 
        this method is here only for the fun of writing code!

        **Time complexity:** O(n), where n is the number of nodes in this TST."""
        c = self._count(self._root, 0)
        assert c == self.size()
        return c

    def _count(self, node: TSTNode, counter: int) -> int:
        """Helper method to `self.count`.

        **Time complexity:** O(m), where m is the number of nodes under `node`."""
        if node is None:  # base case
            return counter

        counter = self._count(node.left, counter)
        if node.value is not None:
            counter += 1

        counter = self._count(node.mid, counter)
        counter = self._count(node.right, counter)

        return counter

    def is_empty(self) -> bool:
        """**Time complexity:** O(1)."""
        return self._n == 0

    def insert(self, key: str, value: object) -> None:
        """Inserts the `key` into the symbol table and associates with it `value`,
        overwriting an eventual associated old value, if the `key` is already in self.

        If `key` is not an instance of `str`, `TypeError` is raised.
        If `key` is an empty string, `ValueError` is raised.
        If `value` is None, `ValueError` is raised.

        Nodes whose value is not None represent the last character of an inserted word.

        **Time complexity:** O(m + h), where m = length(key),
        which also represents how many times we follow the middle link,
        and h is the number of left and right turns.
        So a lower bound of the complexity would be &Omega(m);."""
        self.__invariants__()
        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")
        if value is None:
            raise ValueError("value cannot be None.")
        self._root = self._insert(self._root, key, value, 0)
        self.__invariants__()

    def _insert(self, node: TSTNode, key: str, value: object, index: int):
        """Inserts `key` with `value` into self starting from `node`."""
        if node is None:
            node = TSTNode(key[index])

        if key[index] < node.key:
            node.left = self._insert(node.left, key, value, index)
            node.left.parent = node
        elif key[index] > node.key:
            node.right = self._insert(node.right, key, value, index)
            node.right.parent = node
        else:  # key[index] == node.key
            if index < len(key) - 1:
                # If we're NOT at the end of the key, this is a match,
                # so we recursively call self._insert from index + 1,
                # and we move to the mid node (char) of node.
                # Note that the last index of the key is len(key) - 1.
                node.mid = self._insert(node.mid, key, value, index + 1)
                node.mid.parent = node
            else:
                if node.value is None:
                    self._n += 1
                node.value = value

        return node

    def search(self, key: str) -> object:
        """Returns the value associated with `key`, if `key` is in self, else None.

        If `key` is not an instance of `str`, `TypeError` is raised.
        If `key` is an empty string, `ValueError` is raised.

        The search in a TST works as follows.

        We start at the root and we compare its character with the first character of key.
            - If they are the same, we follow the middle link of the root node.
            - If the first character of key is smaller lexicographically
            than the key at the root, then we take the left link or pointer.
            We do this because we know that all strings that start with characters
            that are smaller lexicographically than key[0] are on its left subtree.
            - If the first character of key is greater lexicographically
            than the key at the root, we take similarly the right link or pointer.

        We keep applying this idea at every node.
        Moreover, WHEN THERE'S A MATCH, next time we compare the key
        of the next node with the next character of key.

        For example, if there's a match between the first node (the root) and key[0],
        we follow the middle link, and the next comparison is between
        the key of the specific next node and key[1], not key[0]!

        **Time complexity:** O(m + h).
        Check self.insert to see what m and h are."""
        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        node = self._search(self._root, key, 0)

        if node is not None:
            assert self.search_iteratively(key) == node.value
            return node.value
        else:
            assert self.search_iteratively(key) is None
            return None

    def _search(self, node: TSTNode, key: str, index: int) -> TSTNode:
        """Searches for the node containing the value associated with `key` starting from `node`.
        If returns None OR a node with value None if there's no such node."""
        if node is None:
            return None

        if key[index] < node.key:
            return self._search(node.left, key, index)
        elif key[index] > node.key:
            return self._search(node.right, key, index)
        elif index < len(key) - 1:  # This is a match, but we're not at the last character of key.
            return self._search(node.mid, key, index + 1)
        else:  # This is a match and we're at the last character of key.
            return node  # node could be None!!

    def search_iteratively(self, key: str) -> object:
        """Iterative alternative to self.search."""
        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        node = self._root

        if node is None:
            return None

        # Up to the penultimate index (i.e. len(key) - 1)
        # because if we reach the penultimate character and it's a match,
        # then we follow the mid node (i.e. we end up in what's possibly the last node).
        index = 0

        while index < len(key) - 1:
            while node and key[index] != node.key:
                if key[index] < node.key:
                    node = node.left
                else:
                    node = node.right

            if node is None:  # Unsuccessful search.
                return None
            else:
                # Arriving here only if exited from the while loop
                # because the condition key[i] != node.key was false,
                # that is key[index] == node.key, thus we follow the middle link.
                node = node.mid
                index += 1

        assert index == len(key) - 1

        # If node is not None, then we may still need to go left or right,
        # and we stop when either we find a node which has the same key as the last character of key,
        # or when `node` ends up being set to None, i.e. the key does not exist in this TST.
        while node and key[index] != node.key:
            if key[index] < node.key:
                node = node.left
            else:
                node = node.right

        if node is None:  # Unsuccessful search.
            return None
        else:  # We exit the previous while loop because key[index] == node.key.
            return node.value  # could also be None!!

    def contains(self, key: str) -> bool:
        """Returns True if `key` is in self, False otherwise.

        **Time complexity:** O(m + h).
        See the complexity analysis of self.insert for more info about m and h."""
        return self.search(key) is not None

    def delete(self, key: str) -> TSTNode:
        """Deletes and returns the value associated with `key` in this TST,
        if `key` is in this TST, otherwise it returns None.

        If `key` is not an instance of `str`, `TypeError` is raised.
        If `key` is an empty string, `ValueError` is raised.

        **Time complexity:** O(m + h + k).
        Check self.search to see what m and h are.
        k is the number of "no more necessary" cleaned up
        after deletion of the node associated with `key`.
        Unnecessary nodes are nodes with no children and value equal to None."""
        self.__invariants__()

        if not isinstance(key, str):
            raise TypeError("key must be an instance of type str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        # Note: calling self._search, since self.search does not return a Node,
        # but the value associated with the key passed as parameter.
        node = self._search(self._root, key, 0)

        if node is not None and node.value is not None:
            # If node.value is None, it means
            result = node.value  # forgetting the string tracked by node.
            node.value = None
            self._n -= 1
            self._delete_fix(node)
        else:
            result = None

        self.__invariants__()
        return result

    def _delete_fix(self, u: TSTNode) -> None:
        """Does the clean up of this TST after deletion of node `u`."""
        assert u.value is None

        # While u has no children and his value is None,
        # forget about u and start from his parent.
        # So, this while loop terminates when either u is None,
        # u has at least one child, or u's value is not None.
        while u and not u.has_children() and u.value is None:
            if self._is_root(u):
                assert self._n == 0
                self._root = None
                break

            if u.is_left_child():
                u.parent.left = None
            elif u.is_right_child():
                u.parent.right = None
            else:
                u.parent.mid = None

            p = u.parent
            u.parent = None
            u = p

        if u.has_children() and u.value is None:
            assert self._count(u, 0) > 0

    def traverse(self) -> None:
        """Traverses all nodes in this TST and prints the key: value associations.

        **Time complexity:** O(n), where n is the number of nodes in self."""
        self._traverse(self._root, "")

    def _traverse(self, node: TSTNode, prefix: str) -> None:
        """Helper method to self.traverse.

        **Time complexity:** O(m), where m is the number of nodes under `node`."""
        if node is None:  # base case
            return

        self._traverse(node.left, prefix)
        if node.value is not None:
            print(prefix + node.key, ": ", node.value)

        self._traverse(node.mid, prefix + node.key)
        self._traverse(node.right, prefix)

    def keys_with_prefix(self, prefix: str) -> list:
        """Returns all keys in this TST that start with `prefix`.

        If `prefix` is not an instance of `str`, `TypeError` is raised.

        If `prefix` is an empty string, then all keys in this TST
        that start with an empty string, thus all keys are returned."""
        if not isinstance(prefix, str):
            raise TypeError("prefix must be an instance of str!")

        kwp = []

        if not prefix:
            self._keys_with_prefix(self._root, [], kwp)
        else:
            node = self._search(self._root, prefix, 0)

            if node is not None:
                if node.value is not None:
                    # A `key` equals to prefix was found in the TST with an associated value.
                    kwp.append(prefix)

                self._keys_with_prefix(node.mid, list(prefix), kwp)

        return kwp

    def _keys_with_prefix(self, node: TSTNode, prefix_list: list, kwp: list) -> None:
        """Returns all keys rooted at `node` given the prefix given as a list of characters `prefix_list`."""
        if node is None:
            return

        self._keys_with_prefix(node.left, prefix_list, kwp)

        if node.value is not None:
            kwp.append("".join(prefix_list + [node.key]))

        prefix_list.append(node.key)
        self._keys_with_prefix(node.mid, prefix_list, kwp)

        prefix_list.pop()
        self._keys_with_prefix(node.right, prefix_list, kwp)

    def all_pairs(self) -> dict:
        """Returns all pairs of key:value from this TST as a Python `dict`."""
        pairs = {}
        self._all_pairs(self._root, [], pairs)
        return pairs

    def _all_pairs(self, node: TSTNode, key_list: list, all_dict: list) -> None:
        if node is None:
            return

        self._all_pairs(node.left, key_list, all_dict)

        if node.value is not None:
            key = "".join(key_list + [node.key])
            assert key not in all_dict
            all_dict[key] = node.value

        key_list.append(node.key)
        self._all_pairs(node.mid, key_list, all_dict)

        key_list.pop()
        self._all_pairs(node.right, key_list, all_dict)

    def longest_prefix_of(self, query: str) -> str:
        """Returns the key in this TST which is the longest prefix of `query`,
        if such a key exists, else it returns None.

        If `query` is not a string `TypeError` is raised.
        If `query` is a string but empty, `ValueError` is raised.

        If this TST is empty, it returns an empty string."""
        if not isinstance(query, str):
            raise TypeError("query is not an instance of str!")
        if not query:
            raise ValueError("empty strings not allowed in this TST!")

        length = 0  # It keeps track of the length of the longest prefix of query.
        x = self._root
        i = 0

        while x is not None and i < len(query):
            c = query[i]

            if c < x.key:
                x = x.left
            elif c > x.key:
                x = x.right
            else:
                i += 1
                if x.value is not None:
                    length = i
                x = x.mid

        return query[:length]

    def keys_that_match(self, pattern: str) -> list:
        """Returns a list of keys of this TST that match `pattern`.

        A key `k` of length `m` matches `pattern` if:

        1. m = length(pattern), and
        2. Either k[i] == pattern[i] or k[i] == '.'.
            - Example: if `pattern == ".ood"`,
            then `k == "good"` would match, but not `k == "foodie"`.

        If `pattern` is not a `str`, `TypeError` is raised.
        If `pattern` is an empty string, `ValueError` is raised."""
        if not isinstance(pattern, str):
            raise TypeError("pattern is not an instance of str!")
        if not pattern:
            raise ValueError("pattern cannot be an empty string")

        keys = []
        self._keys_that_match(self._root, [], 0, pattern, keys)
        return keys

    def _keys_that_match(self, node: TSTNode, prefix_list: list, i: int, pattern: str, keys: list) -> None:
        """Stores in the list `keys` the of keys that match `pattern` starting from `node`."""
        if node is None:
            return

        c = pattern[i]

        if c == "." or c < node.key:
            self._keys_that_match(node.left, prefix_list, i, pattern, keys)

        if c == "." or c == node.key:

            if i == len(pattern) - 1 and node.value is not None:
                # If i is the last index and its value is not None
                keys.append("".join(prefix_list + [node.key]))

            if i < len(pattern) - 1:
                prefix_list.append(node.key)
                self._keys_that_match(node.mid, prefix_list, i + 1, pattern, keys)
                prefix_list.pop()

        if c == "." or c > node.key:
            self._keys_that_match(node.right, prefix_list, i, pattern, keys)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ands.ds.TST.TST">TST</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.__init__" class="source">
    <pre><code>def __init__(self):
    self._n = 0
    self._root = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.all_pairs">
    <p>def <span class="ident">all_pairs</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns all pairs of key:value from this TST as a Python <code>dict</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.all_pairs', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.all_pairs" class="source">
    <pre><code>def all_pairs(self) -> dict:
    """Returns all pairs of key:value from this TST as a Python `dict`."""
    pairs = {}
    self._all_pairs(self._root, [], pairs)
    return pairs
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.contains">
    <p>def <span class="ident">contains</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns True if <code>key</code> is in self, False otherwise.</p>
<p><strong>Time complexity:</strong> O(m + h).
See the complexity analysis of self.insert for more info about m and h.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.contains', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.contains" class="source">
    <pre><code>def contains(self, key: str) -> bool:
    """Returns True if `key` is in self, False otherwise.
    **Time complexity:** O(m + h).
    See the complexity analysis of self.insert for more info about m and h."""
    return self.search(key) is not None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.count">
    <p>def <span class="ident">count</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Counts the number of strings in self.</p>
<p>This method recursively passes through all the nodes
and counts the ones which have a non None value.</p>
<p>You should clearly use size instead: 
this method is here only for the fun of writing code!</p>
<p><strong>Time complexity:</strong> O(n), where n is the number of nodes in this TST.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.count', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.count" class="source">
    <pre><code>def count(self) -> int:
    """Counts the number of strings in self.
    This method recursively passes through all the nodes
    and counts the ones which have a non None value.
    You should clearly use size instead: 
    this method is here only for the fun of writing code!
    **Time complexity:** O(n), where n is the number of nodes in this TST."""
    c = self._count(self._root, 0)
    assert c == self.size()
    return c
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.delete">
    <p>def <span class="ident">delete</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Deletes and returns the value associated with <code>key</code> in this TST,
if <code>key</code> is in this TST, otherwise it returns None.</p>
<p>If <code>key</code> is not an instance of <code>str</code>, <code>TypeError</code> is raised.
If <code>key</code> is an empty string, <code>ValueError</code> is raised.</p>
<p><strong>Time complexity:</strong> O(m + h + k).
Check self.search to see what m and h are.
k is the number of "no more necessary" cleaned up
after deletion of the node associated with <code>key</code>.
Unnecessary nodes are nodes with no children and value equal to None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.delete', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.delete" class="source">
    <pre><code>def delete(self, key: str) -> TSTNode:
    """Deletes and returns the value associated with `key` in this TST,
    if `key` is in this TST, otherwise it returns None.
    If `key` is not an instance of `str`, `TypeError` is raised.
    If `key` is an empty string, `ValueError` is raised.
    **Time complexity:** O(m + h + k).
    Check self.search to see what m and h are.
    k is the number of "no more necessary" cleaned up
    after deletion of the node associated with `key`.
    Unnecessary nodes are nodes with no children and value equal to None."""
    self.__invariants__()
    if not isinstance(key, str):
        raise TypeError("key must be an instance of type str.")
    if not key:
        raise ValueError("key must be a string of length >= 1.")
    # Note: calling self._search, since self.search does not return a Node,
    # but the value associated with the key passed as parameter.
    node = self._search(self._root, key, 0)
    if node is not None and node.value is not None:
        # If node.value is None, it means
        result = node.value  # forgetting the string tracked by node.
        node.value = None
        self._n -= 1
        self._delete_fix(node)
    else:
        result = None
    self.__invariants__()
    return result
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.insert">
    <p>def <span class="ident">insert</span>(</p><p>self, key, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Inserts the <code>key</code> into the symbol table and associates with it <code>value</code>,
overwriting an eventual associated old value, if the <code>key</code> is already in self.</p>
<p>If <code>key</code> is not an instance of <code>str</code>, <code>TypeError</code> is raised.
If <code>key</code> is an empty string, <code>ValueError</code> is raised.
If <code>value</code> is None, <code>ValueError</code> is raised.</p>
<p>Nodes whose value is not None represent the last character of an inserted word.</p>
<p><strong>Time complexity:</strong> O(m + h), where m = length(key),
which also represents how many times we follow the middle link,
and h is the number of left and right turns.
So a lower bound of the complexity would be &amp;Omega(m);.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.insert', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.insert" class="source">
    <pre><code>def insert(self, key: str, value: object) -> None:
    """Inserts the `key` into the symbol table and associates with it `value`,
    overwriting an eventual associated old value, if the `key` is already in self.
    If `key` is not an instance of `str`, `TypeError` is raised.
    If `key` is an empty string, `ValueError` is raised.
    If `value` is None, `ValueError` is raised.
    Nodes whose value is not None represent the last character of an inserted word.
    **Time complexity:** O(m + h), where m = length(key),
    which also represents how many times we follow the middle link,
    and h is the number of left and right turns.
    So a lower bound of the complexity would be &Omega(m);."""
    self.__invariants__()
    if not isinstance(key, str):
        raise TypeError("key must be an instance of type str.")
    if not key:
        raise ValueError("key must be a string of length >= 1.")
    if value is None:
        raise ValueError("value cannot be None.")
    self._root = self._insert(self._root, key, value, 0)
    self.__invariants__()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.is_empty">
    <p>def <span class="ident">is_empty</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>Time complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.is_empty', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.is_empty" class="source">
    <pre><code>def is_empty(self) -> bool:
    """**Time complexity:** O(1)."""
    return self._n == 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.keys_that_match">
    <p>def <span class="ident">keys_that_match</span>(</p><p>self, pattern)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a list of keys of this TST that match <code>pattern</code>.</p>
<p>A key <code>k</code> of length <code>m</code> matches <code>pattern</code> if:</p>
<ol>
<li>m = length(pattern), and</li>
<li>Either k[i] == pattern[i] or k[i] == '.'.<ul>
<li>Example: if <code>pattern == ".ood"</code>,
then <code>k == "good"</code> would match, but not <code>k == "foodie"</code>.</li>
</ul>
</li>
</ol>
<p>If <code>pattern</code> is not a <code>str</code>, <code>TypeError</code> is raised.
If <code>pattern</code> is an empty string, <code>ValueError</code> is raised.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.keys_that_match', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.keys_that_match" class="source">
    <pre><code>def keys_that_match(self, pattern: str) -> list:
    """Returns a list of keys of this TST that match `pattern`.
    A key `k` of length `m` matches `pattern` if:
    1. m = length(pattern), and
    2. Either k[i] == pattern[i] or k[i] == '.'.
        - Example: if `pattern == ".ood"`,
        then `k == "good"` would match, but not `k == "foodie"`.
    If `pattern` is not a `str`, `TypeError` is raised.
    If `pattern` is an empty string, `ValueError` is raised."""
    if not isinstance(pattern, str):
        raise TypeError("pattern is not an instance of str!")
    if not pattern:
        raise ValueError("pattern cannot be an empty string")
    keys = []
    self._keys_that_match(self._root, [], 0, pattern, keys)
    return keys
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.keys_with_prefix">
    <p>def <span class="ident">keys_with_prefix</span>(</p><p>self, prefix)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns all keys in this TST that start with <code>prefix</code>.</p>
<p>If <code>prefix</code> is not an instance of <code>str</code>, <code>TypeError</code> is raised.</p>
<p>If <code>prefix</code> is an empty string, then all keys in this TST
that start with an empty string, thus all keys are returned.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.keys_with_prefix', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.keys_with_prefix" class="source">
    <pre><code>def keys_with_prefix(self, prefix: str) -> list:
    """Returns all keys in this TST that start with `prefix`.
    If `prefix` is not an instance of `str`, `TypeError` is raised.
    If `prefix` is an empty string, then all keys in this TST
    that start with an empty string, thus all keys are returned."""
    if not isinstance(prefix, str):
        raise TypeError("prefix must be an instance of str!")
    kwp = []
    if not prefix:
        self._keys_with_prefix(self._root, [], kwp)
    else:
        node = self._search(self._root, prefix, 0)
        if node is not None:
            if node.value is not None:
                # A `key` equals to prefix was found in the TST with an associated value.
                kwp.append(prefix)
            self._keys_with_prefix(node.mid, list(prefix), kwp)
    return kwp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.longest_prefix_of">
    <p>def <span class="ident">longest_prefix_of</span>(</p><p>self, query)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the key in this TST which is the longest prefix of <code>query</code>,
if such a key exists, else it returns None.</p>
<p>If <code>query</code> is not a string <code>TypeError</code> is raised.
If <code>query</code> is a string but empty, <code>ValueError</code> is raised.</p>
<p>If this TST is empty, it returns an empty string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.longest_prefix_of', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.longest_prefix_of" class="source">
    <pre><code>def longest_prefix_of(self, query: str) -> str:
    """Returns the key in this TST which is the longest prefix of `query`,
    if such a key exists, else it returns None.
    If `query` is not a string `TypeError` is raised.
    If `query` is a string but empty, `ValueError` is raised.
    If this TST is empty, it returns an empty string."""
    if not isinstance(query, str):
        raise TypeError("query is not an instance of str!")
    if not query:
        raise ValueError("empty strings not allowed in this TST!")
    length = 0  # It keeps track of the length of the longest prefix of query.
    x = self._root
    i = 0
    while x is not None and i < len(query):
        c = query[i]
        if c < x.key:
            x = x.left
        elif c > x.key:
            x = x.right
        else:
            i += 1
            if x.value is not None:
                length = i
            x = x.mid
    return query[:length]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.search">
    <p>def <span class="ident">search</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the value associated with <code>key</code>, if <code>key</code> is in self, else None.</p>
<p>If <code>key</code> is not an instance of <code>str</code>, <code>TypeError</code> is raised.
If <code>key</code> is an empty string, <code>ValueError</code> is raised.</p>
<p>The search in a TST works as follows.</p>
<p>We start at the root and we compare its character with the first character of key.
    - If they are the same, we follow the middle link of the root node.
    - If the first character of key is smaller lexicographically
    than the key at the root, then we take the left link or pointer.
    We do this because we know that all strings that start with characters
    that are smaller lexicographically than key[0] are on its left subtree.
    - If the first character of key is greater lexicographically
    than the key at the root, we take similarly the right link or pointer.</p>
<p>We keep applying this idea at every node.
Moreover, WHEN THERE'S A MATCH, next time we compare the key
of the next node with the next character of key.</p>
<p>For example, if there's a match between the first node (the root) and key[0],
we follow the middle link, and the next comparison is between
the key of the specific next node and key[1], not key[0]!</p>
<p><strong>Time complexity:</strong> O(m + h).
Check self.insert to see what m and h are.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.search', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.search" class="source">
    <pre><code>def search(self, key: str) -> object:
    """Returns the value associated with `key`, if `key` is in self, else None.
    If `key` is not an instance of `str`, `TypeError` is raised.
    If `key` is an empty string, `ValueError` is raised.
    The search in a TST works as follows.
    We start at the root and we compare its character with the first character of key.
        - If they are the same, we follow the middle link of the root node.
        - If the first character of key is smaller lexicographically
        than the key at the root, then we take the left link or pointer.
        We do this because we know that all strings that start with characters
        that are smaller lexicographically than key[0] are on its left subtree.
        - If the first character of key is greater lexicographically
        than the key at the root, we take similarly the right link or pointer.
    We keep applying this idea at every node.
    Moreover, WHEN THERE'S A MATCH, next time we compare the key
    of the next node with the next character of key.
    For example, if there's a match between the first node (the root) and key[0],
    we follow the middle link, and the next comparison is between
    the key of the specific next node and key[1], not key[0]!
    **Time complexity:** O(m + h).
    Check self.insert to see what m and h are."""
    if not isinstance(key, str):
        raise TypeError("key must be an instance of type str.")
    if not key:
        raise ValueError("key must be a string of length >= 1.")
    node = self._search(self._root, key, 0)
    if node is not None:
        assert self.search_iteratively(key) == node.value
        return node.value
    else:
        assert self.search_iteratively(key) is None
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.search_iteratively">
    <p>def <span class="ident">search_iteratively</span>(</p><p>self, key)</p>
    </div>
    

    
  
    <div class="desc"><p>Iterative alternative to self.search.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.search_iteratively', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.search_iteratively" class="source">
    <pre><code>def search_iteratively(self, key: str) -> object:
    """Iterative alternative to self.search."""
    if not isinstance(key, str):
        raise TypeError("key must be an instance of type str.")
    if not key:
        raise ValueError("key must be a string of length >= 1.")
    node = self._root
    if node is None:
        return None
    # Up to the penultimate index (i.e. len(key) - 1)
    # because if we reach the penultimate character and it's a match,
    # then we follow the mid node (i.e. we end up in what's possibly the last node).
    index = 0
    while index < len(key) - 1:
        while node and key[index] != node.key:
            if key[index] < node.key:
                node = node.left
            else:
                node = node.right
        if node is None:  # Unsuccessful search.
            return None
        else:
            # Arriving here only if exited from the while loop
            # because the condition key[i] != node.key was false,
            # that is key[index] == node.key, thus we follow the middle link.
            node = node.mid
            index += 1
    assert index == len(key) - 1
    # If node is not None, then we may still need to go left or right,
    # and we stop when either we find a node which has the same key as the last character of key,
    # or when `node` ends up being set to None, i.e. the key does not exist in this TST.
    while node and key[index] != node.key:
        if key[index] < node.key:
            node = node.left
        else:
            node = node.right
    if node is None:  # Unsuccessful search.
        return None
    else:  # We exit the previous while loop because key[index] == node.key.
        return node.value  # could also be None!!
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.size">
    <p>def <span class="ident">size</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.size', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.size" class="source">
    <pre><code>def size(self) -> int:
    return self._n
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TST.traverse">
    <p>def <span class="ident">traverse</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Traverses all nodes in this TST and prints the key: value associations.</p>
<p><strong>Time complexity:</strong> O(n), where n is the number of nodes in self.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TST.traverse', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TST.traverse" class="source">
    <pre><code>def traverse(self) -> None:
    """Traverses all nodes in this TST and prints the key: value associations.
    **Time complexity:** O(n), where n is the number of nodes in self."""
    self._traverse(self._root, "")
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="ands.ds.TST.TSTNode" class="name">class <span class="ident">TSTNode</span></p>
      
  
    <div class="desc"><p>A TSTNode has 6 fields:</p>
<ul>
<li>key, which is a character;</li>
<li>value, which is None if self is not a terminal node (of an inserted string in the TST);</li>
<li>parent, which is a pointer to a TSTNode representing the parent of self;</li>
<li>left, which is a pointer to a TSTNode whose key is smaller lexicographically than key;</li>
<li>right, which is similarly a pointer to a TSTNode whose key is greater lexicographically than key;</li>
<li>mid, which is a pointer to a TSTNode whose key is the following character of key in an inserted string.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TSTNode', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TSTNode" class="source">
    <pre><code>class TSTNode:
    """A TSTNode has 6 fields:

        - key, which is a character;
        - value, which is None if self is not a terminal node (of an inserted string in the TST);
        - parent, which is a pointer to a TSTNode representing the parent of self;
        - left, which is a pointer to a TSTNode whose key is smaller lexicographically than key;
        - right, which is similarly a pointer to a TSTNode whose key is greater lexicographically than key;
        - mid, which is a pointer to a TSTNode whose key is the following character of key in an inserted string."""

    def __init__(self, key, value=None, parent=None, left=None, mid=None, right=None):
        if not isinstance(key, str):
            raise TypeError("key must be an instance of str.")
        if not key:
            raise ValueError("key must be a string of length >= 1.")

        self.key = key
        self.value = value
        self.parent = parent
        self.left = left
        self.mid = mid
        self.right = right

    def is_left_child(self) -> bool:
        if not self.parent:
            raise AttributeError("self does not have a parent.")
        if self.parent.left:
            return self.parent.left == self
        else:
            return False

    def is_right_child(self) -> bool:
        if not self.parent:
            raise AttributeError("self does not have a parent.")
        if self.parent.right:
            return self.parent.right == self
        else:
            return False

    def is_mid_child(self) -> bool:
        if not self.parent:
            raise AttributeError("self does not have a parent.")
        if self.parent.mid:
            return self.parent.mid == self
        else:
            return False

    def has_children(self) -> bool:
        return self.left or self.right or self.mid

    def __str__(self):
        return "{0}: {1}".format(self.key, self.value)

    def __repr__(self):
        return self.__str__()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ands.ds.TST.TSTNode">TSTNode</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TSTNode.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, key, value=None, parent=None, left=None, mid=None, right=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TSTNode.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TSTNode.__init__" class="source">
    <pre><code>def __init__(self, key, value=None, parent=None, left=None, mid=None, right=None):
    if not isinstance(key, str):
        raise TypeError("key must be an instance of str.")
    if not key:
        raise ValueError("key must be a string of length >= 1.")
    self.key = key
    self.value = value
    self.parent = parent
    self.left = left
    self.mid = mid
    self.right = right
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TSTNode.has_children">
    <p>def <span class="ident">has_children</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TSTNode.has_children', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TSTNode.has_children" class="source">
    <pre><code>def has_children(self) -> bool:
    return self.left or self.right or self.mid
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TSTNode.is_left_child">
    <p>def <span class="ident">is_left_child</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TSTNode.is_left_child', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TSTNode.is_left_child" class="source">
    <pre><code>def is_left_child(self) -> bool:
    if not self.parent:
        raise AttributeError("self does not have a parent.")
    if self.parent.left:
        return self.parent.left == self
    else:
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TSTNode.is_mid_child">
    <p>def <span class="ident">is_mid_child</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TSTNode.is_mid_child', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TSTNode.is_mid_child" class="source">
    <pre><code>def is_mid_child(self) -> bool:
    if not self.parent:
        raise AttributeError("self does not have a parent.")
    if self.parent.mid:
        return self.parent.mid == self
    else:
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.TST.TSTNode.is_right_child">
    <p>def <span class="ident">is_right_child</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.TST.TSTNode.is_right_child', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.TST.TSTNode.is_right_child" class="source">
    <pre><code>def is_right_child(self) -> bool:
    if not self.parent:
        raise AttributeError("self does not have a parent.")
    if self.parent.right:
        return self.parent.right == self
    else:
        return False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ands.ds.TST.TSTNode.key" class="name">var <span class="ident">key</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ands.ds.TST.TSTNode.left" class="name">var <span class="ident">left</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ands.ds.TST.TSTNode.mid" class="name">var <span class="ident">mid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ands.ds.TST.TSTNode.parent" class="name">var <span class="ident">parent</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ands.ds.TST.TSTNode.right" class="name">var <span class="ident">right</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ands.ds.TST.TSTNode.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>

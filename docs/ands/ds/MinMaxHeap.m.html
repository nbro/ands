<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ands.ds.MinMaxHeap API documentation</title>
    <meta name="description" content="# Meta info

Author: Nelson Brochado

Created: 18/02/2016

Updated: 29/12/2016

# Description

Min-M..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.is_min_max_heap">is_min_max_heap</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ands.ds.MinMaxHeap.MinMaxHeap">MinMaxHeap</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.__init__">__init__</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.add">add</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.build_heap">build_heap</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.clear">clear</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.contains">contains</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.delete">delete</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.find_max">find_max</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.find_max_index">find_max_index</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.find_min">find_min</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.grandparent_index">grandparent_index</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.has_children">has_children</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.index_of_max">index_of_max</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.index_of_min">index_of_min</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_child">is_child</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_empty">is_empty</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_good_index">is_good_index</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_grandchild">is_grandchild</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_grandparent">is_grandparent</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_on_even_level">is_on_even_level</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_on_odd_level">is_on_odd_level</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.is_parent">is_parent</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.left_index">left_index</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.merge">merge</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.parent_index">parent_index</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.push_down">push_down</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.push_down_max">push_down_max</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.push_down_min">push_down_min</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.push_up">push_up</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.push_up_max">push_up_max</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.push_up_min">push_up_min</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.remove_max">remove_max</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.remove_min">remove_min</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.replace">replace</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.right_index">right_index</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.search">search</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.search_by_value">search_by_value</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.size">size</a></li>
    <li class="mono"><a href="#ands.ds.MinMaxHeap.MinMaxHeap.swap">swap</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ands.ds.MinMaxHeap</span> module</h1>
  <h1>Meta info</h1>
<p>Author: Nelson Brochado</p>
<p>Created: 18/02/2016</p>
<p>Updated: 29/12/2016</p>
<h1>Description</h1>
<p>Min-Max Heap is a heap that supports find-min and find-max operations in constant time.
Moreover, both remove-min and remove-max are supported in logarithmic time.
It's therefore an useful data structure to implement (or represent) double-ended priority queues.</p>
<p>The min-max heap ordering is the following:</p>
<blockquote>
<p>values stored at nodes on even (or min) levels
are smaller than or equal to values stored at their descendants,
whereas values stored at nodes on odd (or max) levels
are greater than or equal to values stored at their descendants.</p>
</blockquote>
<p>Even levels are 0, 2, 4, 6, etc,
whereas odd levels are 1, 3, 5, 7, etc.</p>
<p>The most important methods used to build and support the data structure are:</p>
<ul>
<li>trickle-down (or, also called, bubble-down or shift-down)</li>
<li>trickle-down-min, which is a helper method of trickle-down</li>
<li>trickle-down-max, which is also a helper method of trickle-down</li>
<li>trickle-up (or, also called, bubble-up or shift-up)</li>
<li>trickle-up-min, which is a helper method of trickle-up</li>
<li>trickle-up-max, which is also a helper method of trickle-up</li>
<li>parent-index</li>
<li>grandparent-index</li>
<li>left-child-index</li>
<li>right-child-index</li>
<li>is-on-min-level (or is-on-even-level)</li>
<li>is-on-max-level (or is-on-odd-level)</li>
<li>find-max-element-index</li>
<li>
<p>swap</p>
</li>
<li>
<p><code>add</code> in O(log n) time</p>
</li>
<li><code>delete-at</code> in O(log n) time</li>
<li><code>replace-at</code> in O(log n) time</li>
<li><code>remove-min</code> in O(log n) time</li>
<li><code>remove-max</code> in O(log n) time</li>
<li><code>find-min</code> in O(1) time</li>
<li><code>find-max</code> in O(1) time</li>
<li><code>size</code> in O(1) time</li>
<li><code>is-empty</code> in O(1) time</li>
<li><code>contains</code> in O(n) time</li>
<li><code>merge</code> in O(n + m) time</li>
<li><code>clear</code> in O(1) time</li>
</ul>
<h1>TODO</h1>
<ul>
<li><code>find-kth</code>, i.e. find the kth smallest element in the structure, in O(1) time </li>
<li><code>delete-kth</code>, i.e. delete the kth smallest element, in O(log n) time </li>
</ul>
<h1>References</h1>
<ul>
<li><a href="http://www.akira.ruc.dk/~keld/teaching/algoritmedesign_f03/Artikler/02/Atkinson86.pdf">Min-Max Heaps and Generalized Priority Queues</a>,
original paper describing and introducing the min-max heap data structure, by M. D. Atkinson, J.R. Sack, N. Santoro and T. Strothotte.</li>
<li><a href="http://www.diku.dk/forskning/performance-engineering/Jesper/heaplab/heapsurvey_html/node11.html">http://www.diku.dk/forskning/performance-engineering/Jesper/heaplab/heapsurvey_html/node11.html</a></li>
</ul>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap" class="source">
    <pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
# Meta info

Author: Nelson Brochado

Created: 18/02/2016

Updated: 29/12/2016

# Description

Min-Max Heap is a heap that supports find-min and find-max operations in constant time.
Moreover, both remove-min and remove-max are supported in logarithmic time.
It's therefore an useful data structure to implement (or represent) double-ended priority queues.

The min-max heap ordering is the following:
> values stored at nodes on even (or min) levels
are smaller than or equal to values stored at their descendants,
whereas values stored at nodes on odd (or max) levels
are greater than or equal to values stored at their descendants.

Even levels are 0, 2, 4, 6, etc,
whereas odd levels are 1, 3, 5, 7, etc.

The most important methods used to build and support the data structure are:

- trickle-down (or, also called, bubble-down or shift-down)
- trickle-down-min, which is a helper method of trickle-down
- trickle-down-max, which is also a helper method of trickle-down
- trickle-up (or, also called, bubble-up or shift-up)
- trickle-up-min, which is a helper method of trickle-up
- trickle-up-max, which is also a helper method of trickle-up
- parent-index
- grandparent-index
- left-child-index
- right-child-index
- is-on-min-level (or is-on-even-level)
- is-on-max-level (or is-on-odd-level)
- find-max-element-index
- swap

- `add` in O(log n) time
- `delete-at` in O(log n) time
- `replace-at` in O(log n) time
- `remove-min` in O(log n) time
- `remove-max` in O(log n) time
- `find-min` in O(1) time
- `find-max` in O(1) time
- `size` in O(1) time
- `is-empty` in O(1) time
- `contains` in O(n) time
- `merge` in O(n + m) time
- `clear` in O(1) time

# TODO

- `find-kth`, i.e. find the kth smallest element in the structure, in O(1) time 
- `delete-kth`, i.e. delete the kth smallest element, in O(log n) time 

# References

- [Min-Max Heaps and Generalized Priority Queues](http://www.akira.ruc.dk/~keld/teaching/algoritmedesign_f03/Artikler/02/Atkinson86.pdf),
original paper describing and introducing the min-max heap data structure, by M. D. Atkinson, J.R. Sack, N. Santoro and T. Strothotte.
- [http://www.diku.dk/forskning/performance-engineering/Jesper/heaplab/heapsurvey_html/node11.html](http://www.diku.dk/forskning/performance-engineering/Jesper/heaplab/heapsurvey_html/node11.html)
"""

from ands.ds.heap import BinaryHeap, HeapNode


class MinMaxHeap(BinaryHeap):
    def __init__(self, ls=None):
        BinaryHeap.__init__(self, ls)

    def push_down(self, i: int) -> None:
        """Also called `bubble-down` or `shift-down`."""
        if self.is_on_even_level(i):
            self.push_down_min(i)
        else:
            self.push_down_max(i)

    def push_down_min(self, i: int) -> None:
        """Helper method for `push_down`."""
        if self.has_children(i):
            m = self.index_of_min(i)

            if self.is_grandchild(m, i):
                if self.heap[m] < self.heap[i]:
                    self.swap(i, m)

                    mp = self.parent_index(m)
                    if mp != -1 and self.heap[m] > self.heap[mp]:
                        self.swap(m, mp)
                    self.push_down_min(m)

            else:  # self.heap[m] is a child of self.heap[i]
                if self.heap[m] < self.heap[i]:
                    self.swap(i, m)

    def push_down_max(self, i: int) -> None:
        """Helper method for `push_down`."""
        if self.has_children(i):
            m = self.index_of_max(i)

            if self.is_grandchild(m, i):
                if self.heap[m] > self.heap[i]:
                    self.swap(i, m)

                    mp = self.parent_index(m)
                    if mp != -1 and self.heap[m] < self.heap[mp]:
                        self.swap(m, mp)
                    self.push_down_max(m)

            else:  # self.heap[m] is a child of self.heap[i]
                if self.heap[m] > self.heap[i]:
                    self.swap(i, m)

    def push_up(self, i: int) -> None:
        """Also called `bubble-up` or `shift-up`."""
        p = self.parent_index(i)

        # Let x be the element at index i.
        # If x has a parent at position p, we call it y.
        if self.is_on_even_level(i):
            if p != -1 and self.heap[i] > self.heap[p]:
                # If x is greater than y, swap x with y.
                # Now, x is at index p, and y at index i.
                # push_up_max from the new index of x, i.e. p.
                self.swap(i, p)
                self.push_up_max(p)
            else:
                # x does not have a parent OR x <= y.
                self.push_up_min(i)
        else:
            # Odd or max level.
            if p != -1 and self.heap[i] < self.heap[p]:
                self.swap(i, p)
                self.push_up_min(p)
            else:
                self.push_up_max(i)

    def push_up_min(self, i: int) -> None:
        """Helper method for `push_up`."""
        g = self.grandparent_index(i)
        # Let x be the element at index i.
        # If x has a grandparent at position g,
        # we call it z.

        # If the z exists and x is smaller than z,
        # swap x and z. Now, x is at index g and z at index i.
        if g != -1 and self.heap[i] < self.heap[g]:
            self.swap(i, g)
            self.push_up_min(g)

    def push_up_max(self, i: int) -> None:
        """Helper method for `push_up`."""
        g = self.grandparent_index(i)
        if g != -1 and self.heap[i] > self.heap[g]:
            self.swap(i, g)
            self.push_up_max(g)

    def find_max(self) -> HeapNode:
        """Returns the `HeapNode` object representing the maximum element.

        **Time Complexity:** O(1)."""
        if not self.is_empty():
            return self.heap[self.find_max_index()]

    def find_min(self) -> HeapNode:
        """Returns the `HeapNode` object representing the minimum element.

        **Time Complexity:** O(1)."""
        if not self.is_empty():
            return self.heap[0]

    def remove_max(self) -> HeapNode:
        """Deletes and returns the `HeapNode` object representing the maximum element.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_empty():
            return self.delete(self.find_max_index())

    def remove_min(self) -> HeapNode:
        """Deletes and returns the `HeapNode` object representing the minimum element.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_empty():
            return self.delete(0)

    def delete(self, i: int) -> HeapNode:
        """Deletes and returns the `HeapNode` object at index `i`.

        `IndexError` is raised if `i` is not a valid index.

        Implementation based on:
        [http://www.math.clemson.edu/~warner/M865/HeapDelete.html](http://www.math.clemson.edu/~warner/M865/HeapDelete.html)

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        if i == self.size() - 1:
            return self.heap.pop()
        self.swap(i, self.size() - 1)
        d = self.heap.pop()
        self.push_up(i)
        self.push_down(i)
        return d

    def replace(self, i: int, x):
        """Replace node at index `i` with `x`.

        `x` can either be a key for a HeapNode` object,
        which is created automatically by this function,
        and `x` becomes the key and value of that same `HeapNode` object,
        or it can be (directly) a `HeapNode` object.

        If `x` is NOT a `HeapNode`, it should be comparable
        with the other keys in the other `HeapNode` objects.
        If this is not true, the behaviour of this function is undefined.

        If `x` is a `HeapNode`,
        it's the responsibility of the client of this function
        to make sure it's a "valid" `HeapNode` object,
        i.e. it's comparable to the other `HeapNode` objects in this heap.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        if x is None:
            raise ValueError("x cannot be None.")
        if not isinstance(x, HeapNode):
            x = HeapNode(x)
        d = self.heap[i]
        self.heap[i] = x
        self.push_up(i)
        self.push_down(i)
        return d

    def find_max_index(self) -> int:
        """Returns the index of the maximum element in this min-max heap.

        **Time Complexity:** O(1)."""
        if self.is_empty():
            return -1
        elif self.size() == 1:
            return 0
        elif self.size() == 2:
            return 1
        else:
            return 1 if self.heap[1] > self.heap[2] else 2

    def index_of_min(self, i: int) -> int:
        """Returns the index of the smallest element
        among the children and grandchildren of the node at index `i`.

        **Time Complexity:** O(1)."""
        m = l = self.left_index(i)
        r = self.right_index(i)

        if r != -1 and self.heap[r] < self.heap[m]:
            m = r

        if l != -1:
            gll = self.left_index(l)
            if gll != -1 and self.heap[gll] < self.heap[m]:
                m = gll
            glr = self.right_index(l)
            if glr != -1 and self.heap[glr] < self.heap[m]:
                m = glr

        if r != -1:
            grl = self.left_index(r)
            if grl != -1 and self.heap[grl] < self.heap[m]:
                m = grl
            grr = self.right_index(r)
            if grr != -1 and self.heap[grr] < self.heap[m]:
                m = grr

        return m

    def index_of_max(self, i: int) -> int:
        """Returns the index of the largest element
        among the children and grandchildren of the node at index `i`.

        **Time Complexity:** O(1)."""
        m = l = self.left_index(i)
        r = self.right_index(i)

        if r != -1 and self.heap[r] > self.heap[m]:
            m = r

        if l != -1:
            gll = self.left_index(l)
            if gll != -1 and self.heap[gll] > self.heap[m]:
                m = gll
            glr = self.right_index(l)
            if glr != -1 and self.heap[glr] > self.heap[m]:
                m = glr

        if r != -1:
            grl = self.left_index(r)
            if grl != -1 and self.heap[grl] > self.heap[m]:
                m = grl
            grr = self.right_index(r)
            if grr != -1 and self.heap[grr] > self.heap[m]:
                m = grr

        return m


def is_min_max_heap(h) -> bool:
    """Returns `True` if `h` is a valid `MinMaxHeap` object. `False` otherwise.

    Min-max heap property:
    each node at an EVEN level in the tree is LESS THAN all of its descendants
    while each node at an ODD level in the tree is GREATER THAN all of its descendants."""
    if not isinstance(h, MinMaxHeap):
        return False

    if h.heap:
        for item in h.heap:
            if not isinstance(item, HeapNode):
                return False

        if h.size() == 1:
            return True

        if h.size() == 2:
            return max(h.heap) == h.heap[1] and min(h.heap) == h.heap[0]

        if h.size() >= 3:
            if h.heap[0] != min(h.heap) or (h.heap[1] != max(h.heap) and h.heap[2] != max(h.heap)):
                return False

        # i is the index of the current node
        for i, item in reversed(list(enumerate(h.heap))):

            p = h.parent_index(i)

            if p != -1:
                if h.is_on_even_level(i):
                    if h.heap[p] < item:
                        return False
                else:
                    if h.heap[p] > item:
                        return False

            g = h.grandparent_index(i)
            if g != -1:
                if h.is_on_even_level(i):
                    if h.heap[g] > item:
                        return False
                else:
                    if h.heap[g] < item:
                        return False
    return True
</code></pre>
  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.is_min_max_heap">
    <p>def <span class="ident">is_min_max_heap</span>(</p><p>h)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>h</code> is a valid <code>MinMaxHeap</code> object. <code>False</code> otherwise.</p>
<p>Min-max heap property:
each node at an EVEN level in the tree is LESS THAN all of its descendants
while each node at an ODD level in the tree is GREATER THAN all of its descendants.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.is_min_max_heap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.is_min_max_heap" class="source">
    <pre><code>def is_min_max_heap(h) -> bool:
    """Returns `True` if `h` is a valid `MinMaxHeap` object. `False` otherwise.

    Min-max heap property:
    each node at an EVEN level in the tree is LESS THAN all of its descendants
    while each node at an ODD level in the tree is GREATER THAN all of its descendants."""
    if not isinstance(h, MinMaxHeap):
        return False

    if h.heap:
        for item in h.heap:
            if not isinstance(item, HeapNode):
                return False

        if h.size() == 1:
            return True

        if h.size() == 2:
            return max(h.heap) == h.heap[1] and min(h.heap) == h.heap[0]

        if h.size() >= 3:
            if h.heap[0] != min(h.heap) or (h.heap[1] != max(h.heap) and h.heap[2] != max(h.heap)):
                return False

        # i is the index of the current node
        for i, item in reversed(list(enumerate(h.heap))):

            p = h.parent_index(i)

            if p != -1:
                if h.is_on_even_level(i):
                    if h.heap[p] < item:
                        return False
                else:
                    if h.heap[p] > item:
                        return False

            g = h.grandparent_index(i)
            if g != -1:
                if h.is_on_even_level(i):
                    if h.heap[g] > item:
                        return False
                else:
                    if h.heap[g] < item:
                        return False
    return True
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ands.ds.MinMaxHeap.MinMaxHeap" class="name">class <span class="ident">MinMaxHeap</span></p>
      
  
    <div class="desc"><p>Abstract class to represent binary heaps.</p>
<p><code>MinHeap</code>, <code>MaxHeap</code> and <code>MinMaxHeap</code> all derive from this class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap" class="source">
    <pre><code>class MinMaxHeap(BinaryHeap):
    def __init__(self, ls=None):
        BinaryHeap.__init__(self, ls)

    def push_down(self, i: int) -> None:
        """Also called `bubble-down` or `shift-down`."""
        if self.is_on_even_level(i):
            self.push_down_min(i)
        else:
            self.push_down_max(i)

    def push_down_min(self, i: int) -> None:
        """Helper method for `push_down`."""
        if self.has_children(i):
            m = self.index_of_min(i)

            if self.is_grandchild(m, i):
                if self.heap[m] < self.heap[i]:
                    self.swap(i, m)

                    mp = self.parent_index(m)
                    if mp != -1 and self.heap[m] > self.heap[mp]:
                        self.swap(m, mp)
                    self.push_down_min(m)

            else:  # self.heap[m] is a child of self.heap[i]
                if self.heap[m] < self.heap[i]:
                    self.swap(i, m)

    def push_down_max(self, i: int) -> None:
        """Helper method for `push_down`."""
        if self.has_children(i):
            m = self.index_of_max(i)

            if self.is_grandchild(m, i):
                if self.heap[m] > self.heap[i]:
                    self.swap(i, m)

                    mp = self.parent_index(m)
                    if mp != -1 and self.heap[m] < self.heap[mp]:
                        self.swap(m, mp)
                    self.push_down_max(m)

            else:  # self.heap[m] is a child of self.heap[i]
                if self.heap[m] > self.heap[i]:
                    self.swap(i, m)

    def push_up(self, i: int) -> None:
        """Also called `bubble-up` or `shift-up`."""
        p = self.parent_index(i)

        # Let x be the element at index i.
        # If x has a parent at position p, we call it y.
        if self.is_on_even_level(i):
            if p != -1 and self.heap[i] > self.heap[p]:
                # If x is greater than y, swap x with y.
                # Now, x is at index p, and y at index i.
                # push_up_max from the new index of x, i.e. p.
                self.swap(i, p)
                self.push_up_max(p)
            else:
                # x does not have a parent OR x <= y.
                self.push_up_min(i)
        else:
            # Odd or max level.
            if p != -1 and self.heap[i] < self.heap[p]:
                self.swap(i, p)
                self.push_up_min(p)
            else:
                self.push_up_max(i)

    def push_up_min(self, i: int) -> None:
        """Helper method for `push_up`."""
        g = self.grandparent_index(i)
        # Let x be the element at index i.
        # If x has a grandparent at position g,
        # we call it z.

        # If the z exists and x is smaller than z,
        # swap x and z. Now, x is at index g and z at index i.
        if g != -1 and self.heap[i] < self.heap[g]:
            self.swap(i, g)
            self.push_up_min(g)

    def push_up_max(self, i: int) -> None:
        """Helper method for `push_up`."""
        g = self.grandparent_index(i)
        if g != -1 and self.heap[i] > self.heap[g]:
            self.swap(i, g)
            self.push_up_max(g)

    def find_max(self) -> HeapNode:
        """Returns the `HeapNode` object representing the maximum element.

        **Time Complexity:** O(1)."""
        if not self.is_empty():
            return self.heap[self.find_max_index()]

    def find_min(self) -> HeapNode:
        """Returns the `HeapNode` object representing the minimum element.

        **Time Complexity:** O(1)."""
        if not self.is_empty():
            return self.heap[0]

    def remove_max(self) -> HeapNode:
        """Deletes and returns the `HeapNode` object representing the maximum element.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_empty():
            return self.delete(self.find_max_index())

    def remove_min(self) -> HeapNode:
        """Deletes and returns the `HeapNode` object representing the minimum element.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_empty():
            return self.delete(0)

    def delete(self, i: int) -> HeapNode:
        """Deletes and returns the `HeapNode` object at index `i`.

        `IndexError` is raised if `i` is not a valid index.

        Implementation based on:
        [http://www.math.clemson.edu/~warner/M865/HeapDelete.html](http://www.math.clemson.edu/~warner/M865/HeapDelete.html)

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        if i == self.size() - 1:
            return self.heap.pop()
        self.swap(i, self.size() - 1)
        d = self.heap.pop()
        self.push_up(i)
        self.push_down(i)
        return d

    def replace(self, i: int, x):
        """Replace node at index `i` with `x`.

        `x` can either be a key for a HeapNode` object,
        which is created automatically by this function,
        and `x` becomes the key and value of that same `HeapNode` object,
        or it can be (directly) a `HeapNode` object.

        If `x` is NOT a `HeapNode`, it should be comparable
        with the other keys in the other `HeapNode` objects.
        If this is not true, the behaviour of this function is undefined.

        If `x` is a `HeapNode`,
        it's the responsibility of the client of this function
        to make sure it's a "valid" `HeapNode` object,
        i.e. it's comparable to the other `HeapNode` objects in this heap.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        if x is None:
            raise ValueError("x cannot be None.")
        if not isinstance(x, HeapNode):
            x = HeapNode(x)
        d = self.heap[i]
        self.heap[i] = x
        self.push_up(i)
        self.push_down(i)
        return d

    def find_max_index(self) -> int:
        """Returns the index of the maximum element in this min-max heap.

        **Time Complexity:** O(1)."""
        if self.is_empty():
            return -1
        elif self.size() == 1:
            return 0
        elif self.size() == 2:
            return 1
        else:
            return 1 if self.heap[1] > self.heap[2] else 2

    def index_of_min(self, i: int) -> int:
        """Returns the index of the smallest element
        among the children and grandchildren of the node at index `i`.

        **Time Complexity:** O(1)."""
        m = l = self.left_index(i)
        r = self.right_index(i)

        if r != -1 and self.heap[r] < self.heap[m]:
            m = r

        if l != -1:
            gll = self.left_index(l)
            if gll != -1 and self.heap[gll] < self.heap[m]:
                m = gll
            glr = self.right_index(l)
            if glr != -1 and self.heap[glr] < self.heap[m]:
                m = glr

        if r != -1:
            grl = self.left_index(r)
            if grl != -1 and self.heap[grl] < self.heap[m]:
                m = grl
            grr = self.right_index(r)
            if grr != -1 and self.heap[grr] < self.heap[m]:
                m = grr

        return m

    def index_of_max(self, i: int) -> int:
        """Returns the index of the largest element
        among the children and grandchildren of the node at index `i`.

        **Time Complexity:** O(1)."""
        m = l = self.left_index(i)
        r = self.right_index(i)

        if r != -1 and self.heap[r] > self.heap[m]:
            m = r

        if l != -1:
            gll = self.left_index(l)
            if gll != -1 and self.heap[gll] > self.heap[m]:
                m = gll
            glr = self.right_index(l)
            if glr != -1 and self.heap[glr] > self.heap[m]:
                m = glr

        if r != -1:
            grl = self.left_index(r)
            if grl != -1 and self.heap[grl] > self.heap[m]:
                m = grl
            grr = self.right_index(r)
            if grr != -1 and self.heap[grr] > self.heap[m]:
                m = grr

        return m
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ands.ds.MinMaxHeap.MinMaxHeap">MinMaxHeap</a></li>
          <li>ands.ds.heap.BinaryHeap</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, ls=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.__init__" class="source">
    <pre><code>def __init__(self, ls=None):
    BinaryHeap.__init__(self, ls)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.add">
    <p>def <span class="ident">add</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>x</code> to this heap.</p>
<p>In practice, it places <code>x</code> at an available leaf,
then "bubbles up" from there,
in order to maintain the heap property.</p>
<p><code>x</code> can either be a key or a <code>HeapNode</code> object.
If it's a key, an <code>HeapNode</code> is first created,
whose key and value are equal to <code>x</code>.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.add', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.add" class="source">
    <pre><code>def add(self, x) -> None:
    """Adds `x` to this heap.
    In practice, it places `x` at an available leaf,
    then "bubbles up" from there,
    in order to maintain the heap property.
    `x` can either be a key or a `HeapNode` object.
    If it's a key, an `HeapNode` is first created,
    whose key and value are equal to `x`.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    if x is None:
        raise ValueError("x cannot be None.")
    if not isinstance(x, HeapNode):
        x = HeapNode(x)
    self.heap.append(x)
    if self.size() > 1:
        self.push_up(self.size() - 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.build_heap">
    <p>def <span class="ident">build_heap</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Builds the heap data structure from <code>self.heap</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.build_heap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.build_heap" class="source">
    <pre><code>def build_heap(self) -> list:
    """Builds the heap data structure from `self.heap`."""
    if self.heap:
        for index in range(len(self.heap) // 2, -1, -1):
            self.push_down(index)
    return self.heap
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.clear">
    <p>def <span class="ident">clear</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Clears all nodes from this heap.
This mean that if you call <code>is_empty</code>,
it will return <code>True</code>.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.clear', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.clear" class="source">
    <pre><code>def clear(self) -> None:
    """Clears all nodes from this heap.
    This mean that if you call `is_empty`,
    it will return `True`.
    **Time Complexity:** O(1)."""
    self.heap.clear()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.contains">
    <p>def <span class="ident">contains</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code>, if <code>x</code> is in this heap. <code>False</code> otherwise.</p>
<p><code>x</code> can either be a key or a <code>HeapNode</code> object.
If it's a key, an <code>HeapNode</code> is first created,
whose key and value are equal to <code>x</code>.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.contains', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.contains" class="source">
    <pre><code>def contains(self, x) -> bool:
    """Returns `True`, if `x` is in this heap. `False` otherwise.
    `x` can either be a key or a `HeapNode` object.
    If it's a key, an `HeapNode` is first created,
    whose key and value are equal to `x`.
    **Time Complexity:** O(n)."""
    return self.search(x) != -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.delete">
    <p>def <span class="ident">delete</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Deletes and returns the <code>HeapNode</code> object at index <code>i</code>.</p>
<p><code>IndexError</code> is raised if <code>i</code> is not a valid index.</p>
<p>Implementation based on:
<a href="http://www.math.clemson.edu/~warner/M865/HeapDelete.html">http://www.math.clemson.edu/~warner/M865/HeapDelete.html</a></p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.delete', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.delete" class="source">
    <pre><code>def delete(self, i: int) -> HeapNode:
    """Deletes and returns the `HeapNode` object at index `i`.
    `IndexError` is raised if `i` is not a valid index.
    Implementation based on:
    [http://www.math.clemson.edu/~warner/M865/HeapDelete.html](http://www.math.clemson.edu/~warner/M865/HeapDelete.html)
    **Time Complexity:** O(log<sub>2</sub> n)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    if i == self.size() - 1:
        return self.heap.pop()
    self.swap(i, self.size() - 1)
    d = self.heap.pop()
    self.push_up(i)
    self.push_down(i)
    return d
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.find_max">
    <p>def <span class="ident">find_max</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the <code>HeapNode</code> object representing the maximum element.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.find_max', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.find_max" class="source">
    <pre><code>def find_max(self) -> HeapNode:
    """Returns the `HeapNode` object representing the maximum element.
    **Time Complexity:** O(1)."""
    if not self.is_empty():
        return self.heap[self.find_max_index()]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.find_max_index">
    <p>def <span class="ident">find_max_index</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index of the maximum element in this min-max heap.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.find_max_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.find_max_index" class="source">
    <pre><code>def find_max_index(self) -> int:
    """Returns the index of the maximum element in this min-max heap.
    **Time Complexity:** O(1)."""
    if self.is_empty():
        return -1
    elif self.size() == 1:
        return 0
    elif self.size() == 2:
        return 1
    else:
        return 1 if self.heap[1] > self.heap[2] else 2
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.find_min">
    <p>def <span class="ident">find_min</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the <code>HeapNode</code> object representing the minimum element.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.find_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.find_min" class="source">
    <pre><code>def find_min(self) -> HeapNode:
    """Returns the `HeapNode` object representing the minimum element.
    **Time Complexity:** O(1)."""
    if not self.is_empty():
        return self.heap[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.grandparent_index">
    <p>def <span class="ident">grandparent_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the grandparent's index of the node at index <code>i</code>.</p>
<p>-1 is returned either if <code>i</code> has not a parent or
the parent of <code>i</code> does not have a parent.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.grandparent_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.grandparent_index" class="source">
    <pre><code>def grandparent_index(self, i: int) -> int:
    """Returns the grandparent's index of the node at index `i`.
    -1 is returned either if `i` has not a parent or
    the parent of `i` does not have a parent.
    **Time Complexity:** O(1)."""
    p = self.parent_index(i)
    return -1 if p == -1 else self.parent_index(p)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.has_children">
    <p>def <span class="ident">has_children</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if the node at index <code>i</code>
has at least one child, <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.has_children', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.has_children" class="source">
    <pre><code>def has_children(self, i: int) -> bool:
    """Returns `True` if the node at index `i`
    has at least one child, `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    return self.left_index(i) != -1 or self.right_index(i) != -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.index_of_max">
    <p>def <span class="ident">index_of_max</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index of the largest element
among the children and grandchildren of the node at index <code>i</code>.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.index_of_max', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.index_of_max" class="source">
    <pre><code>def index_of_max(self, i: int) -> int:
    """Returns the index of the largest element
    among the children and grandchildren of the node at index `i`.
    **Time Complexity:** O(1)."""
    m = l = self.left_index(i)
    r = self.right_index(i)
    if r != -1 and self.heap[r] > self.heap[m]:
        m = r
    if l != -1:
        gll = self.left_index(l)
        if gll != -1 and self.heap[gll] > self.heap[m]:
            m = gll
        glr = self.right_index(l)
        if glr != -1 and self.heap[glr] > self.heap[m]:
            m = glr
    if r != -1:
        grl = self.left_index(r)
        if grl != -1 and self.heap[grl] > self.heap[m]:
            m = grl
        grr = self.right_index(r)
        if grr != -1 and self.heap[grr] > self.heap[m]:
            m = grr
    return m
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.index_of_min">
    <p>def <span class="ident">index_of_min</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index of the smallest element
among the children and grandchildren of the node at index <code>i</code>.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.index_of_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.index_of_min" class="source">
    <pre><code>def index_of_min(self, i: int) -> int:
    """Returns the index of the smallest element
    among the children and grandchildren of the node at index `i`.
    **Time Complexity:** O(1)."""
    m = l = self.left_index(i)
    r = self.right_index(i)
    if r != -1 and self.heap[r] < self.heap[m]:
        m = r
    if l != -1:
        gll = self.left_index(l)
        if gll != -1 and self.heap[gll] < self.heap[m]:
            m = gll
        glr = self.right_index(l)
        if glr != -1 and self.heap[glr] < self.heap[m]:
            m = glr
    if r != -1:
        grl = self.left_index(r)
        if grl != -1 and self.heap[grl] < self.heap[m]:
            m = grl
        grr = self.right_index(r)
        if grr != -1 and self.heap[grr] < self.heap[m]:
            m = grr
    return m
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_child">
    <p>def <span class="ident">is_child</span>(</p><p>self, c, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>c</code> is a child of <code>i</code>. <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_child', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_child" class="source">
    <pre><code>def is_child(self, c: int, i: int) -> bool:
    """Returns `True` if `c` is a child of `i`. `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(c) or not self.is_good_index(i):
        raise IndexError("i or c are not valid indexes.")
    return c == self.left_index(i) or c == self.right_index(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_empty">
    <p>def <span class="ident">is_empty</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if this heap is empty.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_empty', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_empty" class="source">
    <pre><code>def is_empty(self) -> bool:
    """Returns `True` if this heap is empty.
    **Time Complexity:** O(1)."""
    return self.size() == 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_good_index">
    <p>def <span class="ident">is_good_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>i</code> is valid index for <code>self.heap</code>,
<code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_good_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_good_index" class="source">
    <pre><code>def is_good_index(self, i: int) -> bool:
    """Returns `True` if `i` is valid index for `self.heap`,
    `False` otherwise.
    **Time Complexity:** O(1)."""
    if not isinstance(i, int):
        raise TypeError("indexes can only be int.")
    return False if (i < 0 or i >= self.size()) else True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_grandchild">
    <p>def <span class="ident">is_grandchild</span>(</p><p>self, g, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>g</code> is a grandchild of <code>i</code>. <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_grandchild', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_grandchild" class="source">
    <pre><code>def is_grandchild(self, g: int, i: int) -> bool:
    """Returns `True` if `g` is a grandchild of `i`. `False` otherwise.
    **Time Complexity:** O(1)."""
    l = self.left_index(i)
    if l == -1:
        assert self.right_index(i) == -1
        if not self.is_good_index(g):
            raise IndexError("g is not a valid index.")
        return False
    r = self.right_index(i)
    if r == -1:
        return self.is_child(g, l)
    else:
        return self.is_child(g, l) or self.is_child(g, r)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_grandparent">
    <p>def <span class="ident">is_grandparent</span>(</p><p>self, g, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>g</code> is the index of the grandparent
of the node at <code>i</code>, <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_grandparent', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_grandparent" class="source">
    <pre><code>def is_grandparent(self, g: int, i: int) -> bool:
    """Returns `True` if `g` is the index of the grandparent
    of the node at `i`, `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(g):
        raise IndexError("g is not a valid index.")
    p = self.parent_index(i)
    return False if p == -1 else self.is_parent(g, p)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_on_even_level">
    <p>def <span class="ident">is_on_even_level</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if node at index <code>i</code> is on a even-level,
i.e., if <code>i</code> is on a level multiple of 2 (0, 2, 4, 6,...).
If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(int(math.log2(i + 1) % 2) == 0).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_on_even_level', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_on_even_level" class="source">
    <pre><code>def is_on_even_level(self, i: int) -> bool:
    """Returns `True` if node at index `i` is on a even-level,
    i.e., if `i` is on a level multiple of 2 (0, 2, 4, 6,...).
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(int(math.log2(i + 1) % 2) == 0)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    return int(math.log2(i + 1) % 2) == 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_on_odd_level">
    <p>def <span class="ident">is_on_odd_level</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> (<code>False</code>) if <code>self.is_on_even_level(i)</code> returns <code>False</code> (<code>True</code>).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_on_odd_level', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_on_odd_level" class="source">
    <pre><code>def is_on_odd_level(self, i: int) -> bool:
    """Returns `True` (`False`) if `self.is_on_even_level(i)` returns `False` (`True`)."""
    return not self.is_on_even_level(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.is_parent">
    <p>def <span class="ident">is_parent</span>(</p><p>self, p, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>p</code> is the index of the parent
of the node at <code>i</code>, <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.is_parent', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.is_parent" class="source">
    <pre><code>def is_parent(self, p: int, i: int) -> bool:
    """Returns `True` if `p` is the index of the parent
    of the node at `i`, `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(p):
        raise IndexError("p is not a valid index.")
    return self.parent_index(i) == p
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.left_index">
    <p>def <span class="ident">left_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the left child's index of the node at index <code>i</code>,
if it exists, otherwise this function returns -1.</p>
<p>If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.left_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.left_index" class="source">
    <pre><code>def left_index(self, i: int) -> int:
    """Returns the left child's index of the node at index `i`,
    if it exists, otherwise this function returns -1.
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    left = i * 2 + 1
    return left if self.is_good_index(left) else -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.merge">
    <p>def <span class="ident">merge</span>(</p><p>self, o)</p>
    </div>
    

    
  
    <div class="desc"><p>Merges this heap with the <code>o</code> heap.</p>
<p>Returns the <code>list</code> object representing internally the new merged heap.</p>
<p><strong>Time Complexity:</strong> O(n + m).</p>
<p>Time complexity analysis based on:
<a href="http://stackoverflow.com/a/29197855/3924118">http://stackoverflow.com/a/29197855/3924118</a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.merge', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.merge" class="source">
    <pre><code>def merge(self, o) -> list:
    """Merges this heap with the `o` heap.
    Returns the `list` object representing internally the new merged heap.
    **Time Complexity:** O(n + m).
    Time complexity analysis based on:
    [http://stackoverflow.com/a/29197855/3924118](http://stackoverflow.com/a/29197855/3924118)."""
    self.heap += o.heap
    return self.build_heap()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.parent_index">
    <p>def <span class="ident">parent_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the parent's index of the node at index <code>i</code>.
If <code>i = 0</code>, then -1 is returned, because the root has no parent.</p>
<p>If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.parent_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.parent_index" class="source">
    <pre><code>def parent_index(self, i: int) -> int:
    """Returns the parent's index of the node at index `i`.
    If `i = 0`, then -1 is returned, because the root has no parent.
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    return -1 if i == 0 else (i - 1) // 2
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.push_down">
    <p>def <span class="ident">push_down</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Also called <code>bubble-down</code> or <code>shift-down</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.push_down', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.push_down" class="source">
    <pre><code>def push_down(self, i: int) -> None:
    """Also called `bubble-down` or `shift-down`."""
    if self.is_on_even_level(i):
        self.push_down_min(i)
    else:
        self.push_down_max(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.push_down_max">
    <p>def <span class="ident">push_down_max</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Helper method for <code>push_down</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.push_down_max', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.push_down_max" class="source">
    <pre><code>def push_down_max(self, i: int) -> None:
    """Helper method for `push_down`."""
    if self.has_children(i):
        m = self.index_of_max(i)
        if self.is_grandchild(m, i):
            if self.heap[m] > self.heap[i]:
                self.swap(i, m)
                mp = self.parent_index(m)
                if mp != -1 and self.heap[m] < self.heap[mp]:
                    self.swap(m, mp)
                self.push_down_max(m)
        else:  # self.heap[m] is a child of self.heap[i]
            if self.heap[m] > self.heap[i]:
                self.swap(i, m)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.push_down_min">
    <p>def <span class="ident">push_down_min</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Helper method for <code>push_down</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.push_down_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.push_down_min" class="source">
    <pre><code>def push_down_min(self, i: int) -> None:
    """Helper method for `push_down`."""
    if self.has_children(i):
        m = self.index_of_min(i)
        if self.is_grandchild(m, i):
            if self.heap[m] < self.heap[i]:
                self.swap(i, m)
                mp = self.parent_index(m)
                if mp != -1 and self.heap[m] > self.heap[mp]:
                    self.swap(m, mp)
                self.push_down_min(m)
        else:  # self.heap[m] is a child of self.heap[i]
            if self.heap[m] < self.heap[i]:
                self.swap(i, m)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.push_up">
    <p>def <span class="ident">push_up</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Also called <code>bubble-up</code> or <code>shift-up</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.push_up', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.push_up" class="source">
    <pre><code>def push_up(self, i: int) -> None:
    """Also called `bubble-up` or `shift-up`."""
    p = self.parent_index(i)
    # Let x be the element at index i.
    # If x has a parent at position p, we call it y.
    if self.is_on_even_level(i):
        if p != -1 and self.heap[i] > self.heap[p]:
            # If x is greater than y, swap x with y.
            # Now, x is at index p, and y at index i.
            # push_up_max from the new index of x, i.e. p.
            self.swap(i, p)
            self.push_up_max(p)
        else:
            # x does not have a parent OR x <= y.
            self.push_up_min(i)
    else:
        # Odd or max level.
        if p != -1 and self.heap[i] < self.heap[p]:
            self.swap(i, p)
            self.push_up_min(p)
        else:
            self.push_up_max(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.push_up_max">
    <p>def <span class="ident">push_up_max</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Helper method for <code>push_up</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.push_up_max', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.push_up_max" class="source">
    <pre><code>def push_up_max(self, i: int) -> None:
    """Helper method for `push_up`."""
    g = self.grandparent_index(i)
    if g != -1 and self.heap[i] > self.heap[g]:
        self.swap(i, g)
        self.push_up_max(g)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.push_up_min">
    <p>def <span class="ident">push_up_min</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Helper method for <code>push_up</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.push_up_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.push_up_min" class="source">
    <pre><code>def push_up_min(self, i: int) -> None:
    """Helper method for `push_up`."""
    g = self.grandparent_index(i)
    # Let x be the element at index i.
    # If x has a grandparent at position g,
    # we call it z.
    # If the z exists and x is smaller than z,
    # swap x and z. Now, x is at index g and z at index i.
    if g != -1 and self.heap[i] < self.heap[g]:
        self.swap(i, g)
        self.push_up_min(g)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.remove_max">
    <p>def <span class="ident">remove_max</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Deletes and returns the <code>HeapNode</code> object representing the maximum element.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.remove_max', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.remove_max" class="source">
    <pre><code>def remove_max(self) -> HeapNode:
    """Deletes and returns the `HeapNode` object representing the maximum element.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    if not self.is_empty():
        return self.delete(self.find_max_index())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.remove_min">
    <p>def <span class="ident">remove_min</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Deletes and returns the <code>HeapNode</code> object representing the minimum element.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.remove_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.remove_min" class="source">
    <pre><code>def remove_min(self) -> HeapNode:
    """Deletes and returns the `HeapNode` object representing the minimum element.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    if not self.is_empty():
        return self.delete(0)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.replace">
    <p>def <span class="ident">replace</span>(</p><p>self, i, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Replace node at index <code>i</code> with <code>x</code>.</p>
<p><code>x</code> can either be a key for a HeapNode<code>object,
which is created automatically by this function,
and</code>x<code>becomes the key and value of that same</code>HeapNode<code>object,
or it can be (directly) a</code>HeapNode` object.</p>
<p>If <code>x</code> is NOT a <code>HeapNode</code>, it should be comparable
with the other keys in the other <code>HeapNode</code> objects.
If this is not true, the behaviour of this function is undefined.</p>
<p>If <code>x</code> is a <code>HeapNode</code>,
it's the responsibility of the client of this function
to make sure it's a "valid" <code>HeapNode</code> object,
i.e. it's comparable to the other <code>HeapNode</code> objects in this heap.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.replace', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.replace" class="source">
    <pre><code>def replace(self, i: int, x):
    """Replace node at index `i` with `x`.
    `x` can either be a key for a HeapNode` object,
    which is created automatically by this function,
    and `x` becomes the key and value of that same `HeapNode` object,
    or it can be (directly) a `HeapNode` object.
    If `x` is NOT a `HeapNode`, it should be comparable
    with the other keys in the other `HeapNode` objects.
    If this is not true, the behaviour of this function is undefined.
    If `x` is a `HeapNode`,
    it's the responsibility of the client of this function
    to make sure it's a "valid" `HeapNode` object,
    i.e. it's comparable to the other `HeapNode` objects in this heap.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    if x is None:
        raise ValueError("x cannot be None.")
    if not isinstance(x, HeapNode):
        x = HeapNode(x)
    d = self.heap[i]
    self.heap[i] = x
    self.push_up(i)
    self.push_down(i)
    return d
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.right_index">
    <p>def <span class="ident">right_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the right child's index of the node at index <code>i</code>,
if it exists, otherwise this function returns -1.</p>
<p>If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.right_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.right_index" class="source">
    <pre><code>def right_index(self, i: int) -> int:
    """Returns the right child's index of the node at index `i`,
    if it exists, otherwise this function returns -1.
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    right = i * 2 + 2
    return right if self.is_good_index(right) else -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.search">
    <p>def <span class="ident">search</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches for <code>x</code> in this heap,
and, if present, returns its index, otherwise returns -1.</p>
<p><code>x</code> can either be a key or a <code>HeapNode</code> object.
If it's a key, an <code>HeapNode</code> is first created,
whose key and value are equal to <code>x</code>.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.search', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.search" class="source">
    <pre><code>def search(self, x) -> int:
    """Searches for `x` in this heap,
    and, if present, returns its index, otherwise returns -1.
    `x` can either be a key or a `HeapNode` object.
    If it's a key, an `HeapNode` is first created,
    whose key and value are equal to `x`.
    **Time Complexity:** O(n)."""
    if x is None:
        raise ValueError("x cannot be None.")
    if not isinstance(x, HeapNode):
        x = HeapNode(x)
    for i, node in enumerate(self.heap):
        if node == x:
            return i
    return -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.search_by_value">
    <p>def <span class="ident">search_by_value</span>(</p><p>self, val)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index of the <code>HeapNode</code> object with <code>value=val</code>.
-1 is returned if no such a <code>HeapNode</code> object exists.</p>
<p>If <code>val</code> and the values in this heap are not comparable,
the behaviour of this method is undefined.</p>
<p>By construction, HeapNode objects can't be initialized with None values,
but that field could also be set manually after creation.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.search_by_value', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.search_by_value" class="source">
    <pre><code>def search_by_value(self, val) -> int:
    """Returns the index of the `HeapNode` object with `value=val`.
    -1 is returned if no such a `HeapNode` object exists.
    If `val` and the values in this heap are not comparable,
    the behaviour of this method is undefined.
    By construction, HeapNode objects can't be initialized with None values,
    but that field could also be set manually after creation.
    **Time Complexity:** O(n)."""
    for i, node in enumerate(self.heap):
        if node.value == val:
            return i
    return -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.size">
    <p>def <span class="ident">size</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the size of this heaps.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.size', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.size" class="source">
    <pre><code>def size(self) -> int:
    """Returns the size of this heaps.
    **Time Complexity:** O(1)."""
    return len(self.heap)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinMaxHeap.MinMaxHeap.swap">
    <p>def <span class="ident">swap</span>(</p><p>self, i, j)</p>
    </div>
    

    
  
    <div class="desc"><p>Swaps elements at indexes <code>i</code> and <code>j</code>,
if they are valid indexes,
otherwise an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinMaxHeap.MinMaxHeap.swap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinMaxHeap.MinMaxHeap.swap" class="source">
    <pre><code>def swap(self, i: int, j: int) -> None:
    """Swaps elements at indexes `i` and `j`,
    if they are valid indexes,
    otherwise an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if self.is_good_index(i) and self.is_good_index(j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    else:
        raise IndexError("i or j are not valid indexes.")
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>

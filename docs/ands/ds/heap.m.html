<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ands.ds.heap API documentation</title>
    <meta name="description" content="# Meta info

Author: Nelson Brochado

Created: 01/07/2015

Updated: 05/02/2017

# Description

This ..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#ands.ds.heap.build_pretty_binary_heap">build_pretty_binary_heap</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ands.ds.heap.BinaryHeap">BinaryHeap</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.__init__">__init__</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.add">add</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.build_heap">build_heap</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.clear">clear</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.contains">contains</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.delete">delete</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.grandparent_index">grandparent_index</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.has_children">has_children</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_child">is_child</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_empty">is_empty</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_good_index">is_good_index</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_grandchild">is_grandchild</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_grandparent">is_grandparent</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_on_even_level">is_on_even_level</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_on_odd_level">is_on_odd_level</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.is_parent">is_parent</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.left_index">left_index</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.merge">merge</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.parent_index">parent_index</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.push_down">push_down</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.push_up">push_up</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.replace">replace</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.right_index">right_index</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.search">search</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.search_by_value">search_by_value</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.size">size</a></li>
    <li class="mono"><a href="#ands.ds.heap.BinaryHeap.swap">swap</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#ands.ds.heap.HeapNode">HeapNode</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ands.ds.heap.HeapNode.__init__">__init__</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ands.ds.heap</span> module</h1>
  <h1>Meta info</h1>
<p>Author: Nelson Brochado</p>
<p>Created: 01/07/2015</p>
<p>Updated: 05/02/2017</p>
<h1>Description</h1>
<p>This module contains currently the classes <code>HeapNode</code>, which is a class to represent nodes of heaps,
the class <code>BinaryHeap</code> and a function which returns a pretty string representation of a heap passed as parameter.</p>
<h1>References</h1>
<ul>
<li><a href="http://www.math.clemson.edu/~warner/M865/HeapDelete.html">http://www.math.clemson.edu/~warner/M865/HeapDelete.html</a></li>
<li>Slides by prof. A. Carzaniga</li>
<li>Chapter 13 of <a href="https://mitpress.mit.edu/books/introduction-algorithms">Introduction to Algorithms (3rd ed.)</a> by CLRS</li>
<li><a href="https://docs.python.org/3/library/exceptions.html#NotImplementedError">NotImplementedError</a></li>
</ul>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap" class="source">
    <pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
# Meta info

Author: Nelson Brochado

Created: 01/07/2015

Updated: 05/02/2017

# Description

This module contains currently the classes `HeapNode`, which is a class to represent nodes of heaps,
the class `BinaryHeap` and a function which returns a pretty string representation of a heap passed as parameter.

# References

- [http://www.math.clemson.edu/~warner/M865/HeapDelete.html](http://www.math.clemson.edu/~warner/M865/HeapDelete.html)
- Slides by prof. A. Carzaniga
- Chapter 13 of [Introduction to Algorithms (3rd ed.)](https://mitpress.mit.edu/books/introduction-algorithms) by CLRS
- [NotImplementedError](https://docs.python.org/3/library/exceptions.html#NotImplementedError)

"""

import io
import math
from collections import Iterable

__all__ = ["BinaryHeap", "HeapNode", "build_pretty_binary_heap"]


class HeapNode:
    """All elements of heap objects are represented with objects of the class HeapNode."""

    def __init__(self, key, value=None):
        """`key` is the priority used to heapify the heap,
        and it must be a non-None comparable value.
        `value` can be used for example for the name of the `HeapNode` object."""
        if key is None:
            raise ValueError("key cannot be None.")
        self.key = key
        self.value = value if value is not None else self.key

    def __eq__(self, o):
        return self.key == o.key and self.value == o.value

    def __ne__(self, o):
        return not self.__eq__(o)

    def __le__(self, o):
        return self.key <= o.key

    def __ge__(self, o):
        return self.key >= o.key

    def __lt__(self, o):
        return not self.__ge__(o)

    def __gt__(self, o):
        return not self.__le__(o)

    def __str__(self):
        return str(self.key)

    def __repr__(self):
        return str(self.value) + " -> " + str(self.key)


class BinaryHeap:
    """Abstract class to represent binary heaps.

    `MinHeap`, `MaxHeap` and `MinMaxHeap` all derive from this class."""

    def __init__(self, ls=None):
        if ls is None:
            ls = []
        self.heap = BinaryHeap._create_list_of_heap_nodes(ls)
        self.build_heap()

    def push_down(self, i: int) -> None:
        """Classical so-called heapify operation for heaps."""
        raise NotImplementedError()

    def push_up(self, i: int) -> None:
        """Classical reverse-heapify operation for heaps."""
        raise NotImplementedError()

    def delete(self, i: int) -> HeapNode:
        raise NotImplementedError()

    def replace(self, i: int, x) -> HeapNode:
        """Replaces the `HeapNode` object at index `i` with `x`.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`."""
        raise NotImplementedError()

    def build_heap(self) -> list:
        """Builds the heap data structure from `self.heap`."""
        if self.heap:
            for index in range(len(self.heap) // 2, -1, -1):
                self.push_down(index)
        return self.heap

    def add(self, x) -> None:
        """Adds `x` to this heap.

        In practice, it places `x` at an available leaf,
        then "bubbles up" from there,
        in order to maintain the heap property.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if x is None:
            raise ValueError("x cannot be None.")
        if not isinstance(x, HeapNode):
            x = HeapNode(x)
        self.heap.append(x)
        if self.size() > 1:
            self.push_up(self.size() - 1)

    def search(self, x) -> int:
        """Searches for `x` in this heap,
        and, if present, returns its index, otherwise returns -1.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`.

        **Time Complexity:** O(n)."""
        if x is None:
            raise ValueError("x cannot be None.")
        if not isinstance(x, HeapNode):
            x = HeapNode(x)
        for i, node in enumerate(self.heap):
            if node == x:
                return i
        return -1

    def search_by_value(self, val) -> int:
        """Returns the index of the `HeapNode` object with `value=val`.
        -1 is returned if no such a `HeapNode` object exists.

        If `val` and the values in this heap are not comparable,
        the behaviour of this method is undefined.

        By construction, HeapNode objects can't be initialized with None values,
        but that field could also be set manually after creation.

        **Time Complexity:** O(n)."""
        for i, node in enumerate(self.heap):
            if node.value == val:
                return i
        return -1

    def contains(self, x) -> bool:
        """Returns `True`, if `x` is in this heap. `False` otherwise.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`.

        **Time Complexity:** O(n)."""
        return self.search(x) != -1

    def merge(self, o) -> list:
        """Merges this heap with the `o` heap.

        Returns the `list` object representing internally the new merged heap.

        **Time Complexity:** O(n + m).

        Time complexity analysis based on:
        [http://stackoverflow.com/a/29197855/3924118](http://stackoverflow.com/a/29197855/3924118)."""
        self.heap += o.heap
        return self.build_heap()

    def size(self) -> int:
        """Returns the size of this heaps.

        **Time Complexity:** O(1)."""
        return len(self.heap)

    def is_empty(self) -> bool:
        """Returns `True` if this heap is empty.

        **Time Complexity:** O(1)."""
        return self.size() == 0

    def clear(self) -> None:
        """Clears all nodes from this heap.
        This mean that if you call `is_empty`,
        it will return `True`.

        **Time Complexity:** O(1)."""
        self.heap.clear()

    def swap(self, i: int, j: int) -> None:
        """Swaps elements at indexes `i` and `j`,
        if they are valid indexes,
        otherwise an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if self.is_good_index(i) and self.is_good_index(j):
            self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
        else:
            raise IndexError("i or j are not valid indexes.")

    # INDEX FUNCTIONS

    def is_good_index(self, i: int) -> bool:
        """Returns `True` if `i` is valid index for `self.heap`,
        `False` otherwise.

        **Time Complexity:** O(1)."""
        if not isinstance(i, int):
            raise TypeError("indexes can only be int.")
        return False if (i < 0 or i >= self.size()) else True

    def parent_index(self, i: int) -> int:
        """Returns the parent's index of the node at index `i`.
        If `i = 0`, then -1 is returned, because the root has no parent.

        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        return -1 if i == 0 else (i - 1) // 2

    def grandparent_index(self, i: int) -> int:
        """Returns the grandparent's index of the node at index `i`.

        -1 is returned either if `i` has not a parent or
        the parent of `i` does not have a parent.

        **Time Complexity:** O(1)."""
        p = self.parent_index(i)
        return -1 if p == -1 else self.parent_index(p)

    def left_index(self, i: int) -> int:
        """Returns the left child's index of the node at index `i`,
        if it exists, otherwise this function returns -1.

        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        left = i * 2 + 1
        return left if self.is_good_index(left) else -1

    def right_index(self, i: int) -> int:
        """Returns the right child's index of the node at index `i`,
        if it exists, otherwise this function returns -1.

        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        right = i * 2 + 2
        return right if self.is_good_index(right) else -1

    def has_children(self, i: int) -> bool:
        """Returns `True` if the node at index `i`
        has at least one child, `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        return self.left_index(i) != -1 or self.right_index(i) != -1

    def is_child(self, c: int, i: int) -> bool:
        """Returns `True` if `c` is a child of `i`. `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(c) or not self.is_good_index(i):
            raise IndexError("i or c are not valid indexes.")
        return c == self.left_index(i) or c == self.right_index(i)

    def is_grandchild(self, g: int, i: int) -> bool:
        """Returns `True` if `g` is a grandchild of `i`. `False` otherwise.

        **Time Complexity:** O(1)."""
        l = self.left_index(i)
        if l == -1:
            assert self.right_index(i) == -1
            if not self.is_good_index(g):
                raise IndexError("g is not a valid index.")
            return False
        r = self.right_index(i)
        if r == -1:
            return self.is_child(g, l)
        else:
            return self.is_child(g, l) or self.is_child(g, r)

    def is_parent(self, p: int, i: int) -> bool:
        """Returns `True` if `p` is the index of the parent
        of the node at `i`, `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(p):
            raise IndexError("p is not a valid index.")
        return self.parent_index(i) == p

    def is_grandparent(self, g: int, i: int) -> bool:
        """Returns `True` if `g` is the index of the grandparent
        of the node at `i`, `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(g):
            raise IndexError("g is not a valid index.")
        p = self.parent_index(i)
        return False if p == -1 else self.is_parent(g, p)

    def is_on_even_level(self, i: int) -> bool:
        """Returns `True` if node at index `i` is on a even-level,
        i.e., if `i` is on a level multiple of 2 (0, 2, 4, 6,...).
        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(int(math.log2(i + 1) % 2) == 0)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        return int(math.log2(i + 1) % 2) == 0

    def is_on_odd_level(self, i: int) -> bool:
        """Returns `True` (`False`) if `self.is_on_even_level(i)` returns `False` (`True`)."""
        return not self.is_on_even_level(i)

    def __str__(self) -> str:
        return str(self.heap)

    def __repr__(self) -> str:
        return build_pretty_binary_heap(self.heap)

    @staticmethod
    def _create_list_of_heap_nodes(ls: list) -> list:
        """Creates and returns a list of `HeapNode`
        objects with the objects in `ls`.

        **Time Complexity:** O(n)."""
        nodes = []
        for _, x in enumerate(ls):
            # x represents also its priority.
            if isinstance(x, (int, float)):
                nodes.append(HeapNode(x))
            else:
                if len(x) != 2:
                    raise ValueError("x should be a tuple or list of 2 elements.")
                # x[0] := priority
                # x[1] := value associated with x[0]
                if x[0] is None or x[1] is None:
                    raise ValueError("keys or values cannot be None.")
                nodes.append(HeapNode(key=x[0], value=x[1]))
        return nodes


def build_pretty_binary_heap(heap: list, total_width=36, fill=" ") -> str:
    """Returns a string (which can be printed) representing `heap` as a tree.

    Adapted for Python 3 from: [http://pymotw.com/2/heapq/](http://pymotw.com/2/heapq/).

    To increase/decrease the horizontal space between nodes,
    just increase/decrease the float number h_space.

    To increase/decrease the vertical space between nodes,
    just increase/decrease the integer number v_space.
    Note that v_space must be an integer.

    To change the length of the line under the heap,
    you can simply change the line_length variable."""
    if not isinstance(heap, Iterable):
        raise TypeError("heap must be an iterable object")
    if len(heap) == 0:
        return "Nothing to print: heap is empty."

    output = io.StringIO()
    last_row = -1

    h_space = 3.0  # float
    v_space = 2  # int

    for i, heap_node in enumerate(heap):
        if i:
            row = int(math.floor(math.log(i + 1, 2)))
        else:
            row = 0

        if row != last_row:
            output.write("\n" * v_space)

        columns = 2 ** row

        column_width = int(math.floor((total_width * h_space) / columns))
        output.write(str(heap_node).center(column_width, fill))
        last_row = row

    s = output.getvalue() + "\n"

    line_length = total_width + 15  # int
    s += ('-' * line_length + "\n")
    return s
</code></pre>
  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="ands.ds.heap.build_pretty_binary_heap">
    <p>def <span class="ident">build_pretty_binary_heap</span>(</p><p>heap, total_width=36, fill=&#39; &#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a string (which can be printed) representing <code>heap</code> as a tree.</p>
<p>Adapted for Python 3 from: <a href="http://pymotw.com/2/heapq/">http://pymotw.com/2/heapq/</a>.</p>
<p>To increase/decrease the horizontal space between nodes,
just increase/decrease the float number h_space.</p>
<p>To increase/decrease the vertical space between nodes,
just increase/decrease the integer number v_space.
Note that v_space must be an integer.</p>
<p>To change the length of the line under the heap,
you can simply change the line_length variable.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.build_pretty_binary_heap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.build_pretty_binary_heap" class="source">
    <pre><code>def build_pretty_binary_heap(heap: list, total_width=36, fill=" ") -> str:
    """Returns a string (which can be printed) representing `heap` as a tree.

    Adapted for Python 3 from: [http://pymotw.com/2/heapq/](http://pymotw.com/2/heapq/).

    To increase/decrease the horizontal space between nodes,
    just increase/decrease the float number h_space.

    To increase/decrease the vertical space between nodes,
    just increase/decrease the integer number v_space.
    Note that v_space must be an integer.

    To change the length of the line under the heap,
    you can simply change the line_length variable."""
    if not isinstance(heap, Iterable):
        raise TypeError("heap must be an iterable object")
    if len(heap) == 0:
        return "Nothing to print: heap is empty."

    output = io.StringIO()
    last_row = -1

    h_space = 3.0  # float
    v_space = 2  # int

    for i, heap_node in enumerate(heap):
        if i:
            row = int(math.floor(math.log(i + 1, 2)))
        else:
            row = 0

        if row != last_row:
            output.write("\n" * v_space)

        columns = 2 ** row

        column_width = int(math.floor((total_width * h_space) / columns))
        output.write(str(heap_node).center(column_width, fill))
        last_row = row

    s = output.getvalue() + "\n"

    line_length = total_width + 15  # int
    s += ('-' * line_length + "\n")
    return s
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ands.ds.heap.BinaryHeap" class="name">class <span class="ident">BinaryHeap</span></p>
      
  
    <div class="desc"><p>Abstract class to represent binary heaps.</p>
<p><code>MinHeap</code>, <code>MaxHeap</code> and <code>MinMaxHeap</code> all derive from this class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap" class="source">
    <pre><code>class BinaryHeap:
    """Abstract class to represent binary heaps.

    `MinHeap`, `MaxHeap` and `MinMaxHeap` all derive from this class."""

    def __init__(self, ls=None):
        if ls is None:
            ls = []
        self.heap = BinaryHeap._create_list_of_heap_nodes(ls)
        self.build_heap()

    def push_down(self, i: int) -> None:
        """Classical so-called heapify operation for heaps."""
        raise NotImplementedError()

    def push_up(self, i: int) -> None:
        """Classical reverse-heapify operation for heaps."""
        raise NotImplementedError()

    def delete(self, i: int) -> HeapNode:
        raise NotImplementedError()

    def replace(self, i: int, x) -> HeapNode:
        """Replaces the `HeapNode` object at index `i` with `x`.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`."""
        raise NotImplementedError()

    def build_heap(self) -> list:
        """Builds the heap data structure from `self.heap`."""
        if self.heap:
            for index in range(len(self.heap) // 2, -1, -1):
                self.push_down(index)
        return self.heap

    def add(self, x) -> None:
        """Adds `x` to this heap.

        In practice, it places `x` at an available leaf,
        then "bubbles up" from there,
        in order to maintain the heap property.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        if x is None:
            raise ValueError("x cannot be None.")
        if not isinstance(x, HeapNode):
            x = HeapNode(x)
        self.heap.append(x)
        if self.size() > 1:
            self.push_up(self.size() - 1)

    def search(self, x) -> int:
        """Searches for `x` in this heap,
        and, if present, returns its index, otherwise returns -1.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`.

        **Time Complexity:** O(n)."""
        if x is None:
            raise ValueError("x cannot be None.")
        if not isinstance(x, HeapNode):
            x = HeapNode(x)
        for i, node in enumerate(self.heap):
            if node == x:
                return i
        return -1

    def search_by_value(self, val) -> int:
        """Returns the index of the `HeapNode` object with `value=val`.
        -1 is returned if no such a `HeapNode` object exists.

        If `val` and the values in this heap are not comparable,
        the behaviour of this method is undefined.

        By construction, HeapNode objects can't be initialized with None values,
        but that field could also be set manually after creation.

        **Time Complexity:** O(n)."""
        for i, node in enumerate(self.heap):
            if node.value == val:
                return i
        return -1

    def contains(self, x) -> bool:
        """Returns `True`, if `x` is in this heap. `False` otherwise.

        `x` can either be a key or a `HeapNode` object.
        If it's a key, an `HeapNode` is first created,
        whose key and value are equal to `x`.

        **Time Complexity:** O(n)."""
        return self.search(x) != -1

    def merge(self, o) -> list:
        """Merges this heap with the `o` heap.

        Returns the `list` object representing internally the new merged heap.

        **Time Complexity:** O(n + m).

        Time complexity analysis based on:
        [http://stackoverflow.com/a/29197855/3924118](http://stackoverflow.com/a/29197855/3924118)."""
        self.heap += o.heap
        return self.build_heap()

    def size(self) -> int:
        """Returns the size of this heaps.

        **Time Complexity:** O(1)."""
        return len(self.heap)

    def is_empty(self) -> bool:
        """Returns `True` if this heap is empty.

        **Time Complexity:** O(1)."""
        return self.size() == 0

    def clear(self) -> None:
        """Clears all nodes from this heap.
        This mean that if you call `is_empty`,
        it will return `True`.

        **Time Complexity:** O(1)."""
        self.heap.clear()

    def swap(self, i: int, j: int) -> None:
        """Swaps elements at indexes `i` and `j`,
        if they are valid indexes,
        otherwise an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if self.is_good_index(i) and self.is_good_index(j):
            self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
        else:
            raise IndexError("i or j are not valid indexes.")

    # INDEX FUNCTIONS

    def is_good_index(self, i: int) -> bool:
        """Returns `True` if `i` is valid index for `self.heap`,
        `False` otherwise.

        **Time Complexity:** O(1)."""
        if not isinstance(i, int):
            raise TypeError("indexes can only be int.")
        return False if (i < 0 or i >= self.size()) else True

    def parent_index(self, i: int) -> int:
        """Returns the parent's index of the node at index `i`.
        If `i = 0`, then -1 is returned, because the root has no parent.

        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        return -1 if i == 0 else (i - 1) // 2

    def grandparent_index(self, i: int) -> int:
        """Returns the grandparent's index of the node at index `i`.

        -1 is returned either if `i` has not a parent or
        the parent of `i` does not have a parent.

        **Time Complexity:** O(1)."""
        p = self.parent_index(i)
        return -1 if p == -1 else self.parent_index(p)

    def left_index(self, i: int) -> int:
        """Returns the left child's index of the node at index `i`,
        if it exists, otherwise this function returns -1.

        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        left = i * 2 + 1
        return left if self.is_good_index(left) else -1

    def right_index(self, i: int) -> int:
        """Returns the right child's index of the node at index `i`,
        if it exists, otherwise this function returns -1.

        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        right = i * 2 + 2
        return right if self.is_good_index(right) else -1

    def has_children(self, i: int) -> bool:
        """Returns `True` if the node at index `i`
        has at least one child, `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        return self.left_index(i) != -1 or self.right_index(i) != -1

    def is_child(self, c: int, i: int) -> bool:
        """Returns `True` if `c` is a child of `i`. `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(c) or not self.is_good_index(i):
            raise IndexError("i or c are not valid indexes.")
        return c == self.left_index(i) or c == self.right_index(i)

    def is_grandchild(self, g: int, i: int) -> bool:
        """Returns `True` if `g` is a grandchild of `i`. `False` otherwise.

        **Time Complexity:** O(1)."""
        l = self.left_index(i)
        if l == -1:
            assert self.right_index(i) == -1
            if not self.is_good_index(g):
                raise IndexError("g is not a valid index.")
            return False
        r = self.right_index(i)
        if r == -1:
            return self.is_child(g, l)
        else:
            return self.is_child(g, l) or self.is_child(g, r)

    def is_parent(self, p: int, i: int) -> bool:
        """Returns `True` if `p` is the index of the parent
        of the node at `i`, `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(p):
            raise IndexError("p is not a valid index.")
        return self.parent_index(i) == p

    def is_grandparent(self, g: int, i: int) -> bool:
        """Returns `True` if `g` is the index of the grandparent
        of the node at `i`, `False` otherwise.

        **Time Complexity:** O(1)."""
        if not self.is_good_index(g):
            raise IndexError("g is not a valid index.")
        p = self.parent_index(i)
        return False if p == -1 else self.is_parent(g, p)

    def is_on_even_level(self, i: int) -> bool:
        """Returns `True` if node at index `i` is on a even-level,
        i.e., if `i` is on a level multiple of 2 (0, 2, 4, 6,...).
        If `i` is not a valid index, an `IndexError` is raised.

        **Time Complexity:** O(int(math.log2(i + 1) % 2) == 0)."""
        if not self.is_good_index(i):
            raise IndexError("i is not a valid index.")
        return int(math.log2(i + 1) % 2) == 0

    def is_on_odd_level(self, i: int) -> bool:
        """Returns `True` (`False`) if `self.is_on_even_level(i)` returns `False` (`True`)."""
        return not self.is_on_even_level(i)

    def __str__(self) -> str:
        return str(self.heap)

    def __repr__(self) -> str:
        return build_pretty_binary_heap(self.heap)

    @staticmethod
    def _create_list_of_heap_nodes(ls: list) -> list:
        """Creates and returns a list of `HeapNode`
        objects with the objects in `ls`.

        **Time Complexity:** O(n)."""
        nodes = []
        for _, x in enumerate(ls):
            # x represents also its priority.
            if isinstance(x, (int, float)):
                nodes.append(HeapNode(x))
            else:
                if len(x) != 2:
                    raise ValueError("x should be a tuple or list of 2 elements.")
                # x[0] := priority
                # x[1] := value associated with x[0]
                if x[0] is None or x[1] is None:
                    raise ValueError("keys or values cannot be None.")
                nodes.append(HeapNode(key=x[0], value=x[1]))
        return nodes
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ands.ds.heap.BinaryHeap">BinaryHeap</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, ls=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.__init__" class="source">
    <pre><code>def __init__(self, ls=None):
    if ls is None:
        ls = []
    self.heap = BinaryHeap._create_list_of_heap_nodes(ls)
    self.build_heap()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.add">
    <p>def <span class="ident">add</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>x</code> to this heap.</p>
<p>In practice, it places <code>x</code> at an available leaf,
then "bubbles up" from there,
in order to maintain the heap property.</p>
<p><code>x</code> can either be a key or a <code>HeapNode</code> object.
If it's a key, an <code>HeapNode</code> is first created,
whose key and value are equal to <code>x</code>.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.add', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.add" class="source">
    <pre><code>def add(self, x) -> None:
    """Adds `x` to this heap.
    In practice, it places `x` at an available leaf,
    then "bubbles up" from there,
    in order to maintain the heap property.
    `x` can either be a key or a `HeapNode` object.
    If it's a key, an `HeapNode` is first created,
    whose key and value are equal to `x`.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    if x is None:
        raise ValueError("x cannot be None.")
    if not isinstance(x, HeapNode):
        x = HeapNode(x)
    self.heap.append(x)
    if self.size() > 1:
        self.push_up(self.size() - 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.build_heap">
    <p>def <span class="ident">build_heap</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Builds the heap data structure from <code>self.heap</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.build_heap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.build_heap" class="source">
    <pre><code>def build_heap(self) -> list:
    """Builds the heap data structure from `self.heap`."""
    if self.heap:
        for index in range(len(self.heap) // 2, -1, -1):
            self.push_down(index)
    return self.heap
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.clear">
    <p>def <span class="ident">clear</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Clears all nodes from this heap.
This mean that if you call <code>is_empty</code>,
it will return <code>True</code>.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.clear', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.clear" class="source">
    <pre><code>def clear(self) -> None:
    """Clears all nodes from this heap.
    This mean that if you call `is_empty`,
    it will return `True`.
    **Time Complexity:** O(1)."""
    self.heap.clear()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.contains">
    <p>def <span class="ident">contains</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code>, if <code>x</code> is in this heap. <code>False</code> otherwise.</p>
<p><code>x</code> can either be a key or a <code>HeapNode</code> object.
If it's a key, an <code>HeapNode</code> is first created,
whose key and value are equal to <code>x</code>.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.contains', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.contains" class="source">
    <pre><code>def contains(self, x) -> bool:
    """Returns `True`, if `x` is in this heap. `False` otherwise.
    `x` can either be a key or a `HeapNode` object.
    If it's a key, an `HeapNode` is first created,
    whose key and value are equal to `x`.
    **Time Complexity:** O(n)."""
    return self.search(x) != -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.delete">
    <p>def <span class="ident">delete</span>(</p><p>self, i)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.delete', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.delete" class="source">
    <pre><code>def delete(self, i: int) -> HeapNode:
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.grandparent_index">
    <p>def <span class="ident">grandparent_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the grandparent's index of the node at index <code>i</code>.</p>
<p>-1 is returned either if <code>i</code> has not a parent or
the parent of <code>i</code> does not have a parent.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.grandparent_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.grandparent_index" class="source">
    <pre><code>def grandparent_index(self, i: int) -> int:
    """Returns the grandparent's index of the node at index `i`.
    -1 is returned either if `i` has not a parent or
    the parent of `i` does not have a parent.
    **Time Complexity:** O(1)."""
    p = self.parent_index(i)
    return -1 if p == -1 else self.parent_index(p)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.has_children">
    <p>def <span class="ident">has_children</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if the node at index <code>i</code>
has at least one child, <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.has_children', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.has_children" class="source">
    <pre><code>def has_children(self, i: int) -> bool:
    """Returns `True` if the node at index `i`
    has at least one child, `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    return self.left_index(i) != -1 or self.right_index(i) != -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_child">
    <p>def <span class="ident">is_child</span>(</p><p>self, c, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>c</code> is a child of <code>i</code>. <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_child', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_child" class="source">
    <pre><code>def is_child(self, c: int, i: int) -> bool:
    """Returns `True` if `c` is a child of `i`. `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(c) or not self.is_good_index(i):
        raise IndexError("i or c are not valid indexes.")
    return c == self.left_index(i) or c == self.right_index(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_empty">
    <p>def <span class="ident">is_empty</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if this heap is empty.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_empty', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_empty" class="source">
    <pre><code>def is_empty(self) -> bool:
    """Returns `True` if this heap is empty.
    **Time Complexity:** O(1)."""
    return self.size() == 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_good_index">
    <p>def <span class="ident">is_good_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>i</code> is valid index for <code>self.heap</code>,
<code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_good_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_good_index" class="source">
    <pre><code>def is_good_index(self, i: int) -> bool:
    """Returns `True` if `i` is valid index for `self.heap`,
    `False` otherwise.
    **Time Complexity:** O(1)."""
    if not isinstance(i, int):
        raise TypeError("indexes can only be int.")
    return False if (i < 0 or i >= self.size()) else True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_grandchild">
    <p>def <span class="ident">is_grandchild</span>(</p><p>self, g, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>g</code> is a grandchild of <code>i</code>. <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_grandchild', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_grandchild" class="source">
    <pre><code>def is_grandchild(self, g: int, i: int) -> bool:
    """Returns `True` if `g` is a grandchild of `i`. `False` otherwise.
    **Time Complexity:** O(1)."""
    l = self.left_index(i)
    if l == -1:
        assert self.right_index(i) == -1
        if not self.is_good_index(g):
            raise IndexError("g is not a valid index.")
        return False
    r = self.right_index(i)
    if r == -1:
        return self.is_child(g, l)
    else:
        return self.is_child(g, l) or self.is_child(g, r)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_grandparent">
    <p>def <span class="ident">is_grandparent</span>(</p><p>self, g, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>g</code> is the index of the grandparent
of the node at <code>i</code>, <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_grandparent', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_grandparent" class="source">
    <pre><code>def is_grandparent(self, g: int, i: int) -> bool:
    """Returns `True` if `g` is the index of the grandparent
    of the node at `i`, `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(g):
        raise IndexError("g is not a valid index.")
    p = self.parent_index(i)
    return False if p == -1 else self.is_parent(g, p)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_on_even_level">
    <p>def <span class="ident">is_on_even_level</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if node at index <code>i</code> is on a even-level,
i.e., if <code>i</code> is on a level multiple of 2 (0, 2, 4, 6,...).
If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(int(math.log2(i + 1) % 2) == 0).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_on_even_level', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_on_even_level" class="source">
    <pre><code>def is_on_even_level(self, i: int) -> bool:
    """Returns `True` if node at index `i` is on a even-level,
    i.e., if `i` is on a level multiple of 2 (0, 2, 4, 6,...).
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(int(math.log2(i + 1) % 2) == 0)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    return int(math.log2(i + 1) % 2) == 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_on_odd_level">
    <p>def <span class="ident">is_on_odd_level</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> (<code>False</code>) if <code>self.is_on_even_level(i)</code> returns <code>False</code> (<code>True</code>).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_on_odd_level', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_on_odd_level" class="source">
    <pre><code>def is_on_odd_level(self, i: int) -> bool:
    """Returns `True` (`False`) if `self.is_on_even_level(i)` returns `False` (`True`)."""
    return not self.is_on_even_level(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.is_parent">
    <p>def <span class="ident">is_parent</span>(</p><p>self, p, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if <code>p</code> is the index of the parent
of the node at <code>i</code>, <code>False</code> otherwise.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.is_parent', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.is_parent" class="source">
    <pre><code>def is_parent(self, p: int, i: int) -> bool:
    """Returns `True` if `p` is the index of the parent
    of the node at `i`, `False` otherwise.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(p):
        raise IndexError("p is not a valid index.")
    return self.parent_index(i) == p
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.left_index">
    <p>def <span class="ident">left_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the left child's index of the node at index <code>i</code>,
if it exists, otherwise this function returns -1.</p>
<p>If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.left_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.left_index" class="source">
    <pre><code>def left_index(self, i: int) -> int:
    """Returns the left child's index of the node at index `i`,
    if it exists, otherwise this function returns -1.
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    left = i * 2 + 1
    return left if self.is_good_index(left) else -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.merge">
    <p>def <span class="ident">merge</span>(</p><p>self, o)</p>
    </div>
    

    
  
    <div class="desc"><p>Merges this heap with the <code>o</code> heap.</p>
<p>Returns the <code>list</code> object representing internally the new merged heap.</p>
<p><strong>Time Complexity:</strong> O(n + m).</p>
<p>Time complexity analysis based on:
<a href="http://stackoverflow.com/a/29197855/3924118">http://stackoverflow.com/a/29197855/3924118</a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.merge', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.merge" class="source">
    <pre><code>def merge(self, o) -> list:
    """Merges this heap with the `o` heap.
    Returns the `list` object representing internally the new merged heap.
    **Time Complexity:** O(n + m).
    Time complexity analysis based on:
    [http://stackoverflow.com/a/29197855/3924118](http://stackoverflow.com/a/29197855/3924118)."""
    self.heap += o.heap
    return self.build_heap()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.parent_index">
    <p>def <span class="ident">parent_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the parent's index of the node at index <code>i</code>.
If <code>i = 0</code>, then -1 is returned, because the root has no parent.</p>
<p>If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.parent_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.parent_index" class="source">
    <pre><code>def parent_index(self, i: int) -> int:
    """Returns the parent's index of the node at index `i`.
    If `i = 0`, then -1 is returned, because the root has no parent.
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    return -1 if i == 0 else (i - 1) // 2
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.push_down">
    <p>def <span class="ident">push_down</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Classical so-called heapify operation for heaps.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.push_down', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.push_down" class="source">
    <pre><code>def push_down(self, i: int) -> None:
    """Classical so-called heapify operation for heaps."""
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.push_up">
    <p>def <span class="ident">push_up</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Classical reverse-heapify operation for heaps.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.push_up', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.push_up" class="source">
    <pre><code>def push_up(self, i: int) -> None:
    """Classical reverse-heapify operation for heaps."""
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.replace">
    <p>def <span class="ident">replace</span>(</p><p>self, i, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Replaces the <code>HeapNode</code> object at index <code>i</code> with <code>x</code>.</p>
<p><code>x</code> can either be a key or a <code>HeapNode</code> object.
If it's a key, an <code>HeapNode</code> is first created,
whose key and value are equal to <code>x</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.replace', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.replace" class="source">
    <pre><code>def replace(self, i: int, x) -> HeapNode:
    """Replaces the `HeapNode` object at index `i` with `x`.
    `x` can either be a key or a `HeapNode` object.
    If it's a key, an `HeapNode` is first created,
    whose key and value are equal to `x`."""
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.right_index">
    <p>def <span class="ident">right_index</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the right child's index of the node at index <code>i</code>,
if it exists, otherwise this function returns -1.</p>
<p>If <code>i</code> is not a valid index, an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.right_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.right_index" class="source">
    <pre><code>def right_index(self, i: int) -> int:
    """Returns the right child's index of the node at index `i`,
    if it exists, otherwise this function returns -1.
    If `i` is not a valid index, an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if not self.is_good_index(i):
        raise IndexError("i is not a valid index.")
    right = i * 2 + 2
    return right if self.is_good_index(right) else -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.search">
    <p>def <span class="ident">search</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches for <code>x</code> in this heap,
and, if present, returns its index, otherwise returns -1.</p>
<p><code>x</code> can either be a key or a <code>HeapNode</code> object.
If it's a key, an <code>HeapNode</code> is first created,
whose key and value are equal to <code>x</code>.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.search', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.search" class="source">
    <pre><code>def search(self, x) -> int:
    """Searches for `x` in this heap,
    and, if present, returns its index, otherwise returns -1.
    `x` can either be a key or a `HeapNode` object.
    If it's a key, an `HeapNode` is first created,
    whose key and value are equal to `x`.
    **Time Complexity:** O(n)."""
    if x is None:
        raise ValueError("x cannot be None.")
    if not isinstance(x, HeapNode):
        x = HeapNode(x)
    for i, node in enumerate(self.heap):
        if node == x:
            return i
    return -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.search_by_value">
    <p>def <span class="ident">search_by_value</span>(</p><p>self, val)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index of the <code>HeapNode</code> object with <code>value=val</code>.
-1 is returned if no such a <code>HeapNode</code> object exists.</p>
<p>If <code>val</code> and the values in this heap are not comparable,
the behaviour of this method is undefined.</p>
<p>By construction, HeapNode objects can't be initialized with None values,
but that field could also be set manually after creation.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.search_by_value', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.search_by_value" class="source">
    <pre><code>def search_by_value(self, val) -> int:
    """Returns the index of the `HeapNode` object with `value=val`.
    -1 is returned if no such a `HeapNode` object exists.
    If `val` and the values in this heap are not comparable,
    the behaviour of this method is undefined.
    By construction, HeapNode objects can't be initialized with None values,
    but that field could also be set manually after creation.
    **Time Complexity:** O(n)."""
    for i, node in enumerate(self.heap):
        if node.value == val:
            return i
    return -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.size">
    <p>def <span class="ident">size</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the size of this heaps.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.size', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.size" class="source">
    <pre><code>def size(self) -> int:
    """Returns the size of this heaps.
    **Time Complexity:** O(1)."""
    return len(self.heap)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.BinaryHeap.swap">
    <p>def <span class="ident">swap</span>(</p><p>self, i, j)</p>
    </div>
    

    
  
    <div class="desc"><p>Swaps elements at indexes <code>i</code> and <code>j</code>,
if they are valid indexes,
otherwise an <code>IndexError</code> is raised.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.BinaryHeap.swap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.BinaryHeap.swap" class="source">
    <pre><code>def swap(self, i: int, j: int) -> None:
    """Swaps elements at indexes `i` and `j`,
    if they are valid indexes,
    otherwise an `IndexError` is raised.
    **Time Complexity:** O(1)."""
    if self.is_good_index(i) and self.is_good_index(j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    else:
        raise IndexError("i or j are not valid indexes.")
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ands.ds.heap.BinaryHeap.heap" class="name">var <span class="ident">heap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="ands.ds.heap.HeapNode" class="name">class <span class="ident">HeapNode</span></p>
      
  
    <div class="desc"><p>All elements of heap objects are represented with objects of the class HeapNode.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.HeapNode', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.HeapNode" class="source">
    <pre><code>class HeapNode:
    """All elements of heap objects are represented with objects of the class HeapNode."""

    def __init__(self, key, value=None):
        """`key` is the priority used to heapify the heap,
        and it must be a non-None comparable value.
        `value` can be used for example for the name of the `HeapNode` object."""
        if key is None:
            raise ValueError("key cannot be None.")
        self.key = key
        self.value = value if value is not None else self.key

    def __eq__(self, o):
        return self.key == o.key and self.value == o.value

    def __ne__(self, o):
        return not self.__eq__(o)

    def __le__(self, o):
        return self.key <= o.key

    def __ge__(self, o):
        return self.key >= o.key

    def __lt__(self, o):
        return not self.__ge__(o)

    def __gt__(self, o):
        return not self.__le__(o)

    def __str__(self):
        return str(self.key)

    def __repr__(self):
        return str(self.value) + " -> " + str(self.key)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ands.ds.heap.HeapNode">HeapNode</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ands.ds.heap.HeapNode.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, key, value=None)</p>
    </div>
    

    
  
    <div class="desc"><p><code>key</code> is the priority used to heapify the heap,
and it must be a non-None comparable value.
<code>value</code> can be used for example for the name of the <code>HeapNode</code> object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.heap.HeapNode.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.heap.HeapNode.__init__" class="source">
    <pre><code>def __init__(self, key, value=None):
    """`key` is the priority used to heapify the heap,
    and it must be a non-None comparable value.
    `value` can be used for example for the name of the `HeapNode` object."""
    if key is None:
        raise ValueError("key cannot be None.")
    self.key = key
    self.value = value if value is not None else self.key
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ands.ds.heap.HeapNode.key" class="name">var <span class="ident">key</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ands.ds.heap.HeapNode.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
